# -*- coding: utf-8 -*-
"""описис_12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oUWVcAn1jjBhueHmdVzYlF48tG30T9Vh
"""

import numpy as np
import math
import matplotlib.pyplot as plt

def harm_signal(x):
    return 2 + As * math.sin(2.0*math.pi*x)

def triangle(x):
    return 2 + 2 * Atr/math.pi * math.asin(math.sin(2 * math.pi / Ttr * (x+Ttr/4)))

fs = float(input('Опорная частота сигнала '))
Tc = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
As = 1.5

Nimp = int(4 * fs * Tc) #Количество импульсов моделирующего сигнала
pimp = float(input('Коэффициент заполнения ПППИ '))
Aimp = 1 #Амплитуда импульса

t = np.linspace(0, Tc, n)
Vin = [0] * n
Vimp = [0] * n

#записываем сигнал
for it in range(n):
    Vin[it] = harm_signal(fs*t[it])

#моделирующий импульсный сигнал
for ii in range(Nimp):
    for it in range(int(n/Nimp * ii), int(n/Nimp * ii + n/Nimp * pimp)):
        Vimp[it] = Aimp

cp = []
for it in range(n):
    if Vimp[it] > 0:
        if Vimp[it - 1] == 0:
            cp.append(it)


Vpam = [0] * n
#Амплитудно-импульсная модуляция
for ii in range(Nimp):
    for it in range(int(n/Nimp * ii), int(n/Nimp * ii + n/Nimp * pimp)):
        Vpam[it] = Vin[it]

Vpwm = [0] * n
Vtr = [0] * n
Atr = As * 1.5
Ttr = 1 / (Nimp / Tc) #1/fs/5
#Широтно-импульсная модуляция
#Задание треугольной волны
for it in range(n):
    Vtr[it] = triangle(t[it])

index = np.argwhere(np.diff(np.sign(np.array(Vtr) - np.array(Vin)))).flatten()
'''
k = 0
while k < len(index):
    for i in range(index[k], index[k+1]):
        Vpwm[i] = Aimp
    k = k+2
'''
k = 0
l = 0
while l < len(index):
    for it in range(cp[k], index[l]):
        Vpwm[it] = Aimp
    k += 1
    l += 2

'''
k = 0
while k < len(index):
    for i in range(index[k], index[k+1]):
        Vpwm[i] = Aimp
    k = k+2
'''
spec_pam = np.fft.fft(Vpam)
spec_pwm = np.fft.fft(Vpwm)
freq = np.fft.fftfreq(n, Tc/n)

plt.figure(figsize=(20, 10))
plt.subplot(3, 2, 1)
plt.plot(t, Vin)
plt.subplot(3, 2, 2)
plt.plot(t, Vimp)
plt.subplot(3, 2, 3)
plt.title('Амплитудно-импульсная модуляция')
plt.plot(t, Vpam)
plt.plot(t, Vin, '--')
plt.subplot(3, 2, 4)
plt.title('Широтно-импульсная модуляция')
plt.plot(t, Vtr)
plt.plot(t, Vin, '--')
plt.plot(np.array(t)[index], np.array(Vtr)[index], 'ro')
plt.plot(t, Vpwm)
plt.subplot(3, 2, 5)
plt.title('Спект амплитудно-импульсной модуляции')
plt.plot(freq[0:n//2], (np.hypot(spec_pam.real, spec_pam.imag)/n*2)[0:n//2])
plt.subplot(3, 2, 6)
plt.title('Спект широтно-импульсной модуляции')
plt.plot(freq[0:n//2], (np.hypot(spec_pwm.real, spec_pwm.imag)/n*2)[0:n//2])
plt.show()

import numpy as np
import math
import matplotlib.pyplot as plt

def harm_signal(x):
    return 2 + As * math.sin(2.0*math.pi*x)

def triangle(x):
    return 2 + 2 * Atr/math.pi * math.asin(math.sin(2 * math.pi / Ttr * (x+Ttr/4)))

fs = float(input('Опорная частота сигнала '))
Tc = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
As = 1.5

Nimp = int(4 * fs * Tc) #Количество импульсов моделирующего сигнала
pimp = float(input('Коэффициент заполнения ПППИ '))
Aimp = 1 #Амплитуда импульса

t = np.linspace(0, Tc, n)
Vin = [0] * n
Vimp = [0] * n

#записываем сигнал
for it in range(n):
    Vin[it] = harm_signal(fs*t[it])

#моделирующий импульсный сигнал
for ii in range(Nimp):
    for it in range(int(n/Nimp * ii), int(n/Nimp * ii + n/Nimp * pimp)):
        Vimp[it] = Aimp

cp = []
for it in range(n):
    if Vimp[it] > 0:
        if Vimp[it - 1] == 0:
            cp.append(it)


Vpam = [0] * n
#Амплитудно-импульсная модуляция
for ii in range(Nimp):
    for it in range(int(n/Nimp * ii), int(n/Nimp * ii + n/Nimp * pimp)):
        Vpam[it] = Vin[int(n/Nimp * ii)]

Vpwm = [0] * n
Vtr = [0] * n
Atr = As * 1.5
Ttr = 1 / (Nimp / Tc) #1/fs/5
#Широтно-импульсная модуляция
#Задание треугольной волны
for it in range(n):
    Vtr[it] = triangle(t[it])

index = np.argwhere(np.diff(np.sign(np.array(Vtr) - np.array(Vin)))).flatten()
'''
k = 0
while k < len(index):
    for i in range(index[k], index[k+1]):
        Vpwm[i] = Aimp
    k = k+2
'''
k = 0
l = 0
while l < len(index):
    for it in range(cp[k], index[l]):
        Vpwm[it] = Aimp
    k += 1
    l += 2

'''
k = 0
while k < len(index):
    for i in range(index[k], index[k+1]):
        Vpwm[i] = Aimp
    k = k+2
'''
spec_pam = np.fft.fft(Vpam)
spec_pwm = np.fft.fft(Vpwm)
freq = np.fft.fftfreq(n, Tc/n)

plt.figure(figsize=(20, 10))
plt.subplot(3, 2, 1)
plt.plot(t, Vin)
plt.subplot(3, 2, 2)
plt.plot(t, Vimp)
plt.subplot(3, 2, 3)
plt.title('Амплитудно-импульсная модуляция')
plt.plot(t, Vpam)
plt.plot(t, Vin, '--')
plt.subplot(3, 2, 4)
plt.title('Широтно-импульсная модуляция')
plt.plot(t, Vtr)
plt.plot(t, Vin, '--')
plt.plot(np.array(t)[index], np.array(Vtr)[index], 'ro')
plt.plot(t, Vpwm)
plt.subplot(3, 2, 5)
plt.title('Спект амплитудно-импульсной модуляции')
plt.plot(freq[0:n//2], (np.hypot(spec_pam.real, spec_pam.imag)/n*2)[0:n//2])
plt.subplot(3, 2, 6)
plt.title('Спект широтно-импульсной модуляции')
plt.plot(freq[0:n//2], (np.hypot(spec_pwm.real, spec_pwm.imag)/n*2)[0:n//2])
plt.show()