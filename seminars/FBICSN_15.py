# -*- coding: utf-8 -*-
"""описис_15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SLK01NgRMJqyeW6ZbO-z-iIvGYhOkgAm
"""

import numpy as np
import math
import matplotlib.pyplot as plt

def f2w(f):
    return 2.0*math.pi*f

def signal(t):
    return As * math.sin(f2w(fs) * t) + 1.5*As * math.sin(f2w(2*fs) * t) + 0.75*As * math.sin(f2w(3*fs) * t)

fs = float(input('Частота первичного сигнала '))
T = float(input('Временной интервал '))
n = 100000
As = 1

sig = np.zeros(n)
time = np.zeros(n)

# Задание сигнала
for i in range(n):
    sig[i] = signal(i * T/n)
    time[i] = i * T/n

# Дискретизация по времени
d_t = 1 / (2*2*3*fs) # шаг дискретизации по времени
d_n = int(T/d_t) # количество дискретных точек
d_sig = np.zeros(d_n)
d_time = np.zeros(d_n)
for i in range(d_n):
    d_sig[i] = sig[i * int(n/d_n)]
    d_time[i] = i * d_t

# Задание уровней напряжения
numberOfLevels = 16
min_level = min(sig)
max_level = max(sig)
d_U = (max_level - min_level) / (numberOfLevels-1) # шаг квантования по уровню
q_U = np.zeros(numberOfLevels)
for i in range(numberOfLevels):
    q_U[i] = min_level + i * d_U
# Квантование по уровню
q_sig = np.zeros(d_n)
for i in range(d_n):
    for j in range(numberOfLevels):
        if abs(d_sig[i] - ((2*j+1)*d_U + 2*min_level)/2) <= d_U/2:
            if d_sig[i] - ((2*j+1)*d_U + 2*min_level)/2 >= 0:
                q_sig[i] = min_level + (j+1) * d_U
            else:
                q_sig[i] = min_level + j * d_U

# Таблица кодирования
lookup_table = {}
unique_levels = sorted(set(q_U))  # отсортируем уникальные значения
for i, level in enumerate(unique_levels):
    code = format(i, '04b')  # двоичный код длиной 4 бита
    lookup_table[level] = code

# пример вывода
for level, code in lookup_table.items():
    print(f"Level {level} -> Code {code}")

coded_signal = [lookup_table[var] for var in q_sig]
print(coded_signal)

int_code = []

for code in coded_signal:
    # переводим строку кода в список целых чисел
    bits = [int(bit) for bit in code]
    int_code.extend(bits)  # добавляем биты к результату
    #int_code.append(2)     # добавляем разделитель

print(int_code)

numberOfBits = len(int_code)
lengthOfBits = int(n / numberOfBits)
result = []

for bit in int_code:
    result.extend([bit] * lengthOfBits)
time_res = np.linspace(0, T, len(result))

plt.figure(figsize=(10,10))
plt.subplot(2, 1, 1)
plt.title('График входного и квантованного сигналов')
plt.plot(time, sig)
for i in range(d_n):
    plt.axvline(x = i*d_t, color='grey', linestyle = '--')
for i in range(numberOfLevels):
    plt.axhline(y = min_level + i * d_U, color = 'grey', linestyle = '--')
plt.scatter(d_time, q_sig, color = 'red')
plt.subplot(2, 1, 2)
plt.title('Импульсно кодовая последовательность')
plt.ylim(-0.1, 1.2)
plt.plot(time_res, result)
for i in range(numberOfBits):
    plt.axvline(x = i*lengthOfBits * T/n, color='grey', linestyle = '--')
    plt.text(((i+0.2)*lengthOfBits * T/n), 1.1, int_code[i], fontsize = 12)
plt.show()

reverse_code = int_code[::-1]

numberOfBits = len(int_code)
lengthOfBits = int(n / numberOfBits)
reverse_result = []

for bit in reverse_code:
    reverse_result.extend([bit] * lengthOfBits)
time_res = np.linspace(0, T, len(result))

inv_code = []
inv_result = []
for bit in int_code:
    inv_code.append(abs(bit - 1))

for bit in inv_code:
    inv_result.extend([bit] * lengthOfBits)
time_res = np.linspace(0, T, len(result))

plt.figure(figsize=(10,10))
plt.subplot(3, 1, 1)
plt.title('Исходная последовательность')
plt.ylim(-0.1, 1.2)
plt.plot(time_res, result)
for i in range(numberOfBits):
    plt.axvline(x = i*lengthOfBits * T/n, color='grey', linestyle = '--')
    plt.text(((i+0.2)*lengthOfBits * T/n), 1.1, int_code[i], fontsize = 12)
plt.subplot(3, 1, 2)
plt.title('Обратная последовательность')
plt.ylim(-0.1, 1.2)
plt.plot(time_res, reverse_result)
for i in range(numberOfBits):
    plt.axvline(x = i*lengthOfBits * T/n, color='grey', linestyle = '--')
    plt.text(((i+0.2)*lengthOfBits * T/n), 1.1, reverse_code[i], fontsize = 12)
plt.subplot(3, 1, 3)
plt.title('Инверсная последовательность')
plt.ylim(-0.1, 1.2)
plt.plot(time_res, inv_result)
for i in range(numberOfBits):
    plt.axvline(x = i*lengthOfBits * T/n, color='grey', linestyle = '--')
    plt.text(((i+0.2)*lengthOfBits * T/n), 1.1, inv_code[i], fontsize = 12)
plt.show()