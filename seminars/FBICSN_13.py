# -*- coding: utf-8 -*-
"""описис_13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RlUVl2EXObvRuIDZU6EC1-vD0CAyO6VL

Провести фазово-импульсную модуляцию гармонического сигнала методом математического расчета для двух разных коэффициентов модуляции. Построить модулированный сигнал и его спектры.
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from scipy import signal

def harm_signal(x):
    return As * math.sin(2.0*math.pi*x)

fs = float(input('Опорная частота сигнала '))
time = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
Mppm = float(input('Коэффициент глубины модуляции ФИМ '))
As = 1.5

Nimp = int(5 * fs * time) #Количество импульсов моделирующего сигнала
pimp = 1/5 #float(input('Коэффициент заполнения ПППИ ')
Aimp = 1 #Амплитуда импульса

t = np.linspace(0, time, n)
Vin = [0] * n
Vimp = [0] * n

#записываем сигнал
for it in range(n):
    Vin[it] = harm_signal(fs*t[it])

#моделированный импульсный сигнал
for ii in range(0, Nimp):
    for it in range(int(n/Nimp * ii), int(n/Nimp * ii + n/Nimp * pimp)):
        Vimp[it] = Aimp

#Фазово-импульсная модуляция
Vcp = [0] * n #массив тактовых точек
Vppm = [0] * n #массив фазово моделированного сигнала
for ii in range(Nimp):
    #расчет смещения каждого импульса в секуднах
    dt = Mppm * As * math.sin(2*math.pi * fs * time/Nimp * ii)
    #print(dt)
    for it in range(int(n/Nimp * ii + dt * n / time), int(n/Nimp * ii + n/Nimp * pimp + dt * n / time)):
        if it < n:
            Vppm[it] = Aimp


Vpfm = [0] * n
Vsaw = [0] * n
Asaw = As * 1.5
fsaw = fs * 4

spec1 = np.fft.fft(Vppm)
sp_fim = np.hypot(spec1.real, spec1.imag)/n*2
freq = np.fft.fftfreq(n, time/n)

plt.figure(figsize=(20, 10))
plt.subplot(2, 2, 1)
plt.title('Входной гармонический сигнал')
plt.plot(t, Vin)
plt.subplot(2, 2, 2)
plt.title('Сигнал переносчик')
plt.plot(t, Vimp)
plt.subplot(2, 2, 3)
plt.title('Спект ФИМ')
plt.plot(freq, sp_fim)
plt.xlim(0, fs*100)
for i in range(100):
    plt.axvline(fs * i, color = 'black', linestyle = ':')
plt.subplot(2, 2, 4)
plt.title('ФИМ сигнал')
plt.plot(t, Vppm)
plt.plot(t, Vin, '--')
for ii in range(Nimp):
    plt.axvline(time/Nimp * ii, color = 'black', linestyle = ':')
plt.show()

import numpy as np
import math
import matplotlib.pyplot as plt
from scipy import signal

def harm_signal(x):
    return As * math.sin(2.0*math.pi*x)

fs = float(input('Опорная частота сигнала '))
time = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
Mppm = float(input('Коэффициент глубины модуляции ФИМ '))
As = 1.5

Nimp = int(5 * fs * time) #Количество импульсов моделирующего сигнала
pimp = 1/5 #float(input('Коэффициент заполнения ПППИ ')
Aimp = 1 #Амплитуда импульса

t = np.linspace(0, time, n)
Vin = [0] * n
Vimp = [0] * n

#записываем сигнал
for it in range(n):
    Vin[it] = harm_signal(fs*t[it])

#моделированный импульсный сигнал
for ii in range(0, Nimp):
    for it in range(int(n/Nimp * ii), int(n/Nimp * ii + n/Nimp * pimp)):
        Vimp[it] = Aimp

#Фазово-импульсная модуляция
Vcp = [0] * n #массив тактовых точек
Vppm = [0] * n #массив фазово моделированного сигнала
for ii in range(Nimp):
    #расчет смещения каждого импульса в секуднах
    dt = Mppm * As * math.sin(2*math.pi * fs * time/Nimp * ii)
    #print(dt)
    for it in range(int(n/Nimp * ii + dt * n / time), int(n/Nimp * ii + n/Nimp * pimp + dt * n / time)):
        if it < n:
            Vppm[it] = Aimp


Vpfm = [0] * n
Vsaw = [0] * n
Asaw = As * 1.5
fsaw = fs * 4

spec1 = np.fft.fft(Vppm)
sp_fim = np.hypot(spec1.real, spec1.imag)/n*2
freq = np.fft.fftfreq(n, time/n)

plt.figure(figsize=(20, 10))
plt.subplot(2, 2, 1)
plt.title('Входной гармонический сигнал')
plt.plot(t, Vin)
plt.subplot(2, 2, 2)
plt.title('Сигнал переносчик')
plt.plot(t, Vimp)
plt.subplot(2, 2, 3)
plt.title('Спект ФИМ')
plt.plot(freq, sp_fim)
plt.xlim(0, fs*100)
for i in range(100):
    plt.axvline(fs * i, color = 'black', linestyle = ':')
plt.subplot(2, 2, 4)
plt.title('ФИМ сигнал')
plt.plot(t, Vppm)
plt.plot(t, Vin, '--')
for ii in range(Nimp):
    plt.axvline(time/Nimp * ii, color = 'black', linestyle = ':')
plt.show()

"""Провести фазово-импульсную модуляцию гармонического сигнала используя треугольную волну. Построить модулированный сигнал и его спектры."""

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Параметры сигнала
fs = float(input('Опорная частота сигнала: '))
time = float(input('Временной интервал: '))
n = int(input('Число временных отсчетов: '))
Mppm = float(input('Коэффициент глубины модуляции ФИМ: '))
As = 1.5

# Параметры моделирующего сигнала
Nimp = int(5 * fs * time)  # Количество импульсов
pimp = 1 / 5  # Коэффициент заполнения
Aimp = 1  # Амплитуда импульса

# Временная ось
t = np.linspace(0, time, n)

# Гармонический сигнал
Vin = As * np.sin(2 * np.pi * fs * t)

# Моделирующий импульсный сигнал
Vimp = np.zeros(n)
for ii in range(Nimp):
    start_idx = int(n / Nimp * ii)
    end_idx = int(n / Nimp * (ii + pimp))
    Vimp[start_idx:end_idx] = Aimp

# Фазово-импульсная модуляция
Vppm = np.zeros(n)
for ii in range(Nimp):
    dt = Mppm * As * signal.sawtooth(2 * np.pi * fs * (time / Nimp) * ii, width=0.5)
    start_idx = max(0, min(n - 1, int(n / Nimp * ii + dt * n / time)))
    end_idx = max(0, min(n - 1, int(n / Nimp * ii + n / Nimp * pimp + dt * n / time)))
    Vppm[start_idx:end_idx] = Aimp

# Спектр ФИМ
spec1 = np.fft.fft(Vppm)
sp_fim = np.abs(spec1[:n // 2]) / n
sp_fim[1:] *= 2  # Удвоение амплитуд для положительных частот
freq = np.fft.fftfreq(n, d=time / n)[:n // 2]

# Треугольная волна
saw_amp = As  # Амплитуда треугольной волны
saw_freq = fs  # Частота треугольной волны
Vsaw = saw_amp * signal.sawtooth(2 * np.pi * saw_freq * t, width=0.5)

# Графики
plt.figure(figsize=(20, 10))

plt.subplot(2, 2, 1)
plt.title('Входной гармонический сигнал')
plt.plot(t, Vin)

plt.subplot(2, 2, 2)
plt.title('Сигнал переносчик')
plt.plot(t, Vimp)

plt.subplot(2, 2, 3)
plt.title('Спектр ФИМ')
plt.plot(freq, sp_fim)
plt.xlim(0, fs * 100)
for i in range(100):
    plt.axvline(fs * i, color='black', linestyle=':')

plt.subplot(2, 2, 4)
plt.title('ФИМ сигнал с треугольной волной')
plt.plot(t, Vppm, label='ФИМ сигнал')
plt.plot(t, Vin, '--', label='Гармонический сигнал')
plt.plot(t, Vsaw, ':', label='Треугольная волна', color='green')
plt.legend()
for ii in range(Nimp):
    plt.axvline(time / Nimp * ii, color='black', linestyle=':', label='Импульсы' if ii == 0 else "")

plt.show()