# -*- coding: utf-8 -*-
"""описис_16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w-ePoIS__KEbTnJV41d5ZlDGgDnyucg9
"""

import numpy as np
import math
import matplotlib.pyplot as plt

def f2w(f):
    return 2.0*math.pi*f

def signal(t):
    return As * math.sin(f2w(fs) * t) + 1.5*As * math.sin(f2w(2*fs) * t) + 0.75*As * math.sin(f2w(3*fs) * t)

def bipolar_pulse_code(binary):
    signal = []
    for bit in binary:
        if bit == 1:
            signal.append(1)   # высокий уровень
            signal.append(0)   # возврат к 0
        else:
            signal.append(-1)  # низкий уровень
            signal.append(0)   # возврат к 0
    return signal

fs = 10 #float(input('Частота первичного сигнала '))
T = 0.1 #float(input('Временной интервал '))
n = 100000
As = 1

sig = np.zeros(n)
time = np.zeros(n)

# Задание сигнала
for i in range(n):
    sig[i] = signal(i * T/n)
    time[i] = i * T/n

# Дискретизация по времени
d_t = 1 / (2*2*3*fs) # шаг дискретизации по времени
d_n = int(T/d_t) # количество дискретных точек
d_sig = np.zeros(d_n)
d_time = np.zeros(d_n)
for i in range(d_n):
    d_sig[i] = sig[i * int(n/d_n)]
    d_time[i] = i * d_t

# Задание уровней напряжения
numberOfLevels = 16
min_level = min(sig)
max_level = max(sig)
d_U = (max_level - min_level) / (numberOfLevels-1) # шаг квантования по уровню
q_U = np.zeros(numberOfLevels)
for i in range(numberOfLevels):
    q_U[i] = min_level + i * d_U
# Квантование по уровню
q_sig = np.zeros(d_n)
for i in range(d_n):
    for j in range(numberOfLevels):
        if abs(d_sig[i] - ((2*j+1)*d_U + 2*min_level)/2) <= d_U/2:
            if d_sig[i] - ((2*j+1)*d_U + 2*min_level)/2 >= 0:
                q_sig[i] = min_level + (j+1) * d_U
            else:
                q_sig[i] = min_level + j * d_U

# Таблица кодирования
lookup_table = {}
unique_levels = sorted(set(q_U))  # отсортируем уникальные значения
for i, level in enumerate(unique_levels):
    code = format(i, '04b')  # двоичный код длиной 4 бита
    lookup_table[level] = code

# пример вывода
for level, code in lookup_table.items():
    print(f"Level {level} -> Code {code}")

coded_signal = [lookup_table[var] for var in q_sig]
print(coded_signal)

int_code = []

for code in coded_signal:
    # переводим строку кода в список целых чисел
    bits = [int(bit) for bit in code]
    int_code.extend(bits)  # добавляем биты к результату
    #int_code.append(2)     # добавляем разделитель

print(int_code)

numberOfBits = len(int_code)
lengthOfBits = int(n / numberOfBits)
result = []

for bit in int_code:
    result.extend([bit] * lengthOfBits)
time_res = np.linspace(0, T, len(result))

bipolar_signal_result = []
bipolar_signal = bipolar_pulse_code(int_code)
for bit in bipolar_signal:
    bipolar_signal_result.extend([bit] * int(lengthOfBits/2))
time_res_2 = np.linspace(0, T, len(bipolar_signal_result))

plt.figure(figsize=(10,10))
plt.subplot(3, 1, 1)
plt.title('График входного и квантованного сигналов')
plt.plot(time, sig)
for i in range(d_n):
    plt.axvline(x = i*d_t, color='grey', linestyle = '--')
for i in range(numberOfLevels):
    plt.axhline(y = min_level + i * d_U, color = 'grey', linestyle = '--')
plt.scatter(d_time, q_sig, color = 'red')
plt.subplot(3, 1, 2)
plt.title('Импульсно кодовая последовательность')
plt.ylim(-0.1, 1.2)
plt.plot(time_res, result)
for i in range(numberOfBits):
    plt.axvline(x = i*lengthOfBits * T/n, color='grey', linestyle = '--')
    plt.text(((i+0.2)*lengthOfBits * T/n), 1.1, int_code[i], fontsize = 12)
plt.subplot(3, 1, 3)
plt.title('Биполярный импульсный код')
plt.ylim(-1.2, 1.4)
plt.plot(time_res_2, bipolar_signal_result)
for i in range(numberOfBits):
    plt.axvline(x = i*lengthOfBits * T/n, color='grey', linestyle = '--')
    plt.text(((i+0.2)*lengthOfBits * T/n), 1.1, int_code[i], fontsize = 12)
plt.show()

import numpy as np
import math
import matplotlib.pyplot as plt

def f2w(f):
    return 2.0*math.pi*f

def signal(t):
    return As * math.sin(f2w(fs) * t) + 1.5*As * math.sin(f2w(2*fs) * t) + 0.75*As * math.sin(f2w(3*fs) * t)


def bipolar_pulse_AMI_code(binary, count):
    signal = []
    for bit in binary:
        if bit == 1 and count % 2 == 1:
            signal.append(-1)   # высокий уровень
            count += 1
        elif bit == 1 and count % 2 == 0:
            signal.append(1)   # высокий уровень
            count += 1
        else:
            signal.append(0)   # возврат к 0
    return signal, count

count = 0
fs = 10 #float(input('Частота первичного сигнала '))
T = 0.1 #float(input('Временной интервал '))
n = 100000
As = 1

sig = np.zeros(n)
time = np.zeros(n)

# Задание сигнала
for i in range(n):
    sig[i] = signal(i * T/n)
    time[i] = i * T/n

# Дискретизация по времени
d_t = 1 / (2*2*3*fs) # шаг дискретизации по времени
d_n = int(T/d_t) # количество дискретных точек
d_sig = np.zeros(d_n)
d_time = np.zeros(d_n)
for i in range(d_n):
    d_sig[i] = sig[i * int(n/d_n)]
    d_time[i] = i * d_t

# Задание уровней напряжения
numberOfLevels = 16
min_level = min(sig)
max_level = max(sig)
d_U = (max_level - min_level) / (numberOfLevels-1) # шаг квантования по уровню
q_U = np.zeros(numberOfLevels)
for i in range(numberOfLevels):
    q_U[i] = min_level + i * d_U
# Квантование по уровню
q_sig = np.zeros(d_n)
for i in range(d_n):
    for j in range(numberOfLevels):
        if abs(d_sig[i] - ((2*j+1)*d_U + 2*min_level)/2) <= d_U/2:
            if d_sig[i] - ((2*j+1)*d_U + 2*min_level)/2 >= 0:
                q_sig[i] = min_level + (j+1) * d_U
            else:
                q_sig[i] = min_level + j * d_U

# Таблица кодирования
lookup_table = {}
unique_levels = sorted(set(q_U))  # отсортируем уникальные значения
for i, level in enumerate(unique_levels):
    code = format(i, '04b')  # двоичный код длиной 4 бита
    lookup_table[level] = code

# пример вывода
for level, code in lookup_table.items():
    print(f"Level {level} -> Code {code}")

coded_signal = [lookup_table[var] for var in q_sig]
print(coded_signal)

int_code = []

for code in coded_signal:
    # переводим строку кода в список целых чисел
    bits = [int(bit) for bit in code]
    int_code.extend(bits)  # добавляем биты к результату
    #int_code.append(2)     # добавляем разделитель

print(int_code)

numberOfBits = len(int_code)
lengthOfBits = int(n / numberOfBits)
result = []

for bit in int_code:
    result.extend([bit] * lengthOfBits)
time_res = np.linspace(0, T, len(result))

bipolar_signal_result = []
bipolar_signal, count = bipolar_pulse_AMI_code(int_code, count)
for bit in bipolar_signal:
    bipolar_signal_result.extend([bit] * int(lengthOfBits/2))
time_res_2 = np.linspace(0, T, len(bipolar_signal_result))

plt.figure(figsize=(10,10))
plt.subplot(3, 1, 1)
plt.title('График входного и квантованного сигналов')
plt.plot(time, sig)
for i in range(d_n):
    plt.axvline(x = i*d_t, color='grey', linestyle = '--')
for i in range(numberOfLevels):
    plt.axhline(y = min_level + i * d_U, color = 'grey', linestyle = '--')
plt.scatter(d_time, q_sig, color = 'red')
plt.subplot(3, 1, 2)
plt.title('Импульсно кодовая последовательность')
plt.ylim(-0.1, 1.2)
plt.plot(time_res, result)
for i in range(numberOfBits):
    plt.axvline(x = i*lengthOfBits * T/n, color='grey', linestyle = '--')
    plt.text(((i+0.2)*lengthOfBits * T/n), 1.1, int_code[i], fontsize = 12)
plt.subplot(3, 1, 3)
plt.title('Биполярный импульсный код')
plt.ylim(-1.2, 1.4)
plt.plot(time_res_2, bipolar_signal_result)
for i in range(numberOfBits):
    plt.axvline(x = i*lengthOfBits * T/n, color='grey', linestyle = '--')
    plt.text(((i+0.2)*lengthOfBits * T/n), 1.1, int_code[i], fontsize = 12)
plt.show()

import numpy as np
import math
import matplotlib.pyplot as plt

def f2w(f):
    return 2.0*math.pi*f

def signal(t):
    return As * math.sin(f2w(fs) * t) + 1.5*As * math.sin(f2w(2*fs) * t) + 0.75*As * math.sin(f2w(3*fs) * t)


def manch_code(binary):
    signal = []
    for bit in binary:
        if bit == 1:
            signal.append(0)
            signal.append(1)   # высокий уровень
        else:
            signal.append(1)
            signal.append(0)   # возврат к 0
    return signal

fs = 10 #float(input('Частота первичного сигнала '))
T = 0.1 #float(input('Временной интервал '))
n = 100000
As = 1

sig = np.zeros(n)
time = np.zeros(n)

# Задание сигнала
for i in range(n):
    sig[i] = signal(i * T/n)
    time[i] = i * T/n

# Дискретизация по времени
d_t = 1 / (2*2*3*fs) # шаг дискретизации по времени
d_n = int(T/d_t) # количество дискретных точек
d_sig = np.zeros(d_n)
d_time = np.zeros(d_n)
for i in range(d_n):
    d_sig[i] = sig[i * int(n/d_n)]
    d_time[i] = i * d_t

# Задание уровней напряжения
numberOfLevels = 16
min_level = min(sig)
max_level = max(sig)
d_U = (max_level - min_level) / (numberOfLevels-1) # шаг квантования по уровню
q_U = np.zeros(numberOfLevels)
for i in range(numberOfLevels):
    q_U[i] = min_level + i * d_U
# Квантование по уровню
q_sig = np.zeros(d_n)
for i in range(d_n):
    for j in range(numberOfLevels):
        if abs(d_sig[i] - ((2*j+1)*d_U + 2*min_level)/2) <= d_U/2:
            if d_sig[i] - ((2*j+1)*d_U + 2*min_level)/2 >= 0:
                q_sig[i] = min_level + (j+1) * d_U
            else:
                q_sig[i] = min_level + j * d_U

# Таблица кодирования
lookup_table = {}
unique_levels = sorted(set(q_U))  # отсортируем уникальные значения
for i, level in enumerate(unique_levels):
    code = format(i, '04b')  # двоичный код длиной 4 бита
    lookup_table[level] = code

# пример вывода
for level, code in lookup_table.items():
    print(f"Level {level} -> Code {code}")

coded_signal = [lookup_table[var] for var in q_sig]
print(coded_signal)

int_code = []

for code in coded_signal:
    # переводим строку кода в список целых чисел
    bits = [int(bit) for bit in code]
    int_code.extend(bits)  # добавляем биты к результату
    #int_code.append(2)     # добавляем разделитель

print(int_code)

numberOfBits = len(int_code)
lengthOfBits = int(n / numberOfBits)
result = []

for bit in int_code:
    result.extend([bit] * lengthOfBits)
time_res = np.linspace(0, T, len(result))

bipolar_signal_result = []
bipolar_signal = manch_code(int_code)
for bit in bipolar_signal:
    bipolar_signal_result.extend([bit] * int(lengthOfBits/2))
time_res_2 = np.linspace(0, T, len(bipolar_signal_result))

plt.figure(figsize=(10,10))
plt.subplot(3, 1, 1)
plt.title('График входного и квантованного сигналов')
plt.plot(time, sig)
for i in range(d_n):
    plt.axvline(x = i*d_t, color='grey', linestyle = '--')
for i in range(numberOfLevels):
    plt.axhline(y = min_level + i * d_U, color = 'grey', linestyle = '--')
plt.scatter(d_time, q_sig, color = 'red')
plt.subplot(3, 1, 2)
plt.title('Импульсно кодовая последовательность')
plt.ylim(-0.1, 1.2)
plt.plot(time_res, result)
for i in range(numberOfBits):
    plt.axvline(x = i*lengthOfBits * T/n, color='grey', linestyle = '--')
    plt.text(((i+0.2)*lengthOfBits * T/n), 1.1, int_code[i], fontsize = 12)
plt.subplot(3, 1, 3)
plt.title('Биполярный импульсный код')
plt.ylim(-1.1, 1.4)
plt.plot(time_res_2, bipolar_signal_result)
for i in range(numberOfBits):
    plt.axvline(x = i*lengthOfBits * T/n, color='grey', linestyle = '--')
    plt.text(((i+0.2)*lengthOfBits * T/n), 1.1, int_code[i], fontsize = 12)
plt.show()