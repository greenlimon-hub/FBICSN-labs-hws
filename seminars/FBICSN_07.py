# -*- coding: utf-8 -*-
"""описис_07.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dQdz_m5jiL4JGSMIdhZUfO5MNAGgl5f_
"""

import numpy as np
from math import *
import matplotlib.pyplot as plt
import time
import sys

def func_int(x):
    y = sin(x) + 1.5 + cos(x)
    return y

"""# Нелинейных уравнений методами дихотомии и ньютона"""

def func_nonlin(x):
     y = pow(exp, x) - 1 - cos(x)
     return y

def func_nonlin_partial(x):
    y_p = pow(exp, x) + sin(x)
    return y_p

def newton():
    x0 = b
    while abs(func_nonlin(x0)) > eps:
        x0 = x0 - func_nonlin(x0) / func_nonlin_partial(x0)
    return x0

def dichotomy():
    a1 = a
    b1 = b
    if func_nonlin(a1) * func_nonlin(b1) > 0:
        print('Неверный выбор границ для метода дихотомии')
        return
    else:
        c1 = (a1 + b1) / 2
        while abs(func_nonlin(c1)) > eps:
            if func_nonlin(a1) * func_nonlin(c1) < 0:
                b1 = c1
            else:
                a1 = c1
            c1 = (a1 + b1) / 2
        return c1

exp = 2.7182818284
eps = 0.000001

a = float(input('Левая начальная граница '))
b = int(input('Правая начальная граница '))

print('\n' + 'Результат расчета методом дихотомии:' + str(dichotomy()))
print('\n' + 'Результат расчета методом Ньютона:' + str(newton()))

"""# Интегральных уравнений методами левых прямоугольников и трапеций"""

def Integration_left_rect(n):
    integral = 0
    for i in range(0, n):
        integral += (b-a)/n * func_int(a + (b-a) * i / n)
    return integral

def Integration_trapezoid(n):
    integral = 0
    for i in range(0, n-1):
        integral += (b-a)/n * (func_int(a + (b-a) * i / n) + func_int(a + (b-a) * (i + 1) / n)) / 2
    return integral

a = 0 #начало интегрирования
b = 8 #конец интегрирования
n = 100 #количество делений

print('\n' + 'Результат расчета интегралла методом левых прямоугольников: ' + str(Integration_left_rect(n)))
print('\n' + 'Результат расчета интегралла методом трапеций: ' + str(Integration_trapezoid(n)))

"""# Дифференциальных уравнений методом Рунге-Кутта 4го порядка"""

def Euler_methon():
    # Параметры уравнения
    omega = 2.0  # Угловая частота
    h = 0.01  # Шаг по времени
    T = 10  # Время моделирования

    # Начальные условия
    y0 = 1.0  # Начальное смещение
    v0 = 0.0  # Начальная скорость

    # Временная сетка
    t_values = np.arange(0, T, h)

    # Метод Рунге-Кутта 4-го порядка
    y_rk4 = []
    v_rk4 = []
    y = y0
    v = v0
    for t in t_values:
        y_rk4.append(y)
        v_rk4.append(v)

        k1_y = h * v
        k1_v = -h * omega**2 * y

        k2_y = h * (v + k1_v / 2)
        k2_v = -h * omega**2 * (y + k1_y / 2)

        k3_y = h * (v + k2_v / 2)
        k3_v = -h * omega**2 * (y + k2_y / 2)

        k4_y = h * (v + k3_v)
        k4_v = -h * omega**2 * (y + k3_y)

        y += (k1_y + 2*k2_y + 2*k3_y + k4_y) / 6
        v += (k1_v + 2*k2_v + 2*k3_v + k4_v) / 6

    # График
    plt.plot(t_values, y_rk4, label='Рунге-Кутта (смещение)')
    plt.plot(t_values, v_rk4, label='Рунге-Кутта (скорость)')
    plt.xlabel('Время t')
    plt.ylabel('y')
    plt.legend()
    plt.title('Решение уравнения колебаний: Метод Рунге-Кутта')
    plt.grid()
    plt.show()

Euler_methon()

"""# Нелинейных уравнений модифицированным методом Ньютона"""

def newton_mod():
    x0 = b
    f_prime_x0 = func_nonlin_partial(x0)  # Вычисляем производную один раз

    if abs(f_prime_x0) < eps:  # Проверка, чтобы избежать деления на ноль
        raise ValueError("Производная близка к нулю. Метод не применим.")

    while abs(func_nonlin(x0)) > eps:
        x0 = x0 - func_nonlin(x0) / f_prime_x0
    return x0

exp = 2.7182818284
eps = 0.000001

b = int(input('Правая начальная граница '))

print('\n' + 'Результат расчета методом Ньютона:' + str(newton()))

"""# Интегральных уравнений методом средних прямоугольников"""

def Integration_average_rect(n):
    integral = 0
    for i in range(0, n):
        integral += (b-a)/n * func_int((a + (b-a) * i / n)/2)
    return integral

a = 0 #начало интегрирования
b = 10 #конец интегрирования
n = 100 #количество делений

print('\n' + 'Результат расчета интегралла методом левых прямоугольников: ' + str(Integration_average_rect(n)))

"""# Дифференциальных уравнений методом Эйлера"""

def Euler_methon():
    # Параметры уравнения
    omega = 2.0  # Угловая частота
    h = 0.01  # Шаг по времени
    T = 10  # Время моделирования

    # Начальные условия
    y0 = 1.0  # Начальное смещение
    v0 = 0.0  # Начальная скорость

    # Временная сетка
    t_values = np.arange(0, T, h)

    # Метод Рунге-Кутта 4-го порядка
    y = []
    v = []
    y_i = y0
    v_i = v0
    for t in t_values:
      y.append(y_i)
      v.append(v_i)
      v_i -= omega**2 * y[-1] * h
      y_i +=  v[-1] * h
    print(y_i)

    # График
    plt.plot(t_values, y, label='Эйлера (смещение)')
    plt.plot(t_values, v, label='Эйлера (скорость)')
    plt.xlabel('Время t')
    plt.ylabel('y')
    plt.legend()
    plt.title('Решение уравнения колебаний: Метод Эйлера')
    plt.grid()
    plt.show()

Euler_methon()

"""наложить эйлера на рунге кутта, написать о разницу в отчете."""