# -*- coding: utf-8 -*-
"""описис_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wKR5DZfFjscOdmJKdDEp_1wHR9k51VCG
"""

import numpy as np
from math import *
import matplotlib.pyplot as plt

def signal(x):
    return 1.0 + sin(2.0*pi*x) + 2.0 * cos(4.0*pi*x) + 0.5 * cos(6.0*pi*x)

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

fp = open('data.csv', 'w', encoding='utf-8')

t = np.linspace(0, T, n)
u = [0] * n

t_sig = np.linspace(0, T, 256)
u_sig = [0] * 256

fp.write('t; u\n')
for i in range(n):
    u[i] = signal(f*t[i])
    fp.write('{0: f}; {1: f}\n'.format(t[i], u[i]))

fp.close()

plt.figure()
plt.plot(t, u, color='tab:orange')
plt.plot(t, u, 'o', color='tab:orange')
plt.vlines(t, 0, u, color='tab:orange', lw=1)
plt.show()

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

fp = open('data.csv', 'w', encoding='utf-8')

t = np.linspace(0, T, n)
u = [0] * n

fp.write('t; u\n')
for i in range(n):
    u[i] = signal(f*t[i])
    fp.write('{0: f}; {1: f}\n'.format(t[i], u[i]))

fp.close()

plt.figure()
plt.plot(t, u)
plt.plot(t, u, color='tab:blue')
plt.plot(t, u, 'o', color='tab:green')
plt.vlines(t, 0, u, color='tab:orange', lw=1)
plt.show()

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

fp = open('data.csv', 'w', encoding='utf-8')

t = np.linspace(0, T, n)
u = [0] * n

fp.write('t; u\n')
for i in range(n):
    u[i] = signal(f*t[i])
    fp.write('{0: f}; {1: f}\n'.format(t[i], u[i]))

fp.close()

plt.figure()
plt.plot(t, u)
plt.plot(t, u, 'o', color='tab:green')
plt.vlines(t, 0, u, color='tab:orange', lw=1)
plt.show()

import numpy as np
from math import *
import matplotlib.pyplot as plt

def signal(x):
    return 1.0 + sin(2.0*pi*x) + 2.0 * cos(4.0*pi*x) + 0.5 * cos(6.0*pi*x)

def quantize(signal_values, delta, n):
    # Квантование сигнала на заданное количество уровней
    ampl = max(signal_values) - min(signal_values)
    quant = [0] * n
    for i in range(n):
      quant[i] = round(signal_values[i] / delta) * delta
    return quant

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
delta = float(input('Введите шаг квантования: '))

fp = open('data.csv', 'w', encoding='utf-8')

t = np.linspace(0, T, n)
u = [0] * n

fp.write('t; u\n')
for i in range(n):
    u[i] = signal(f*t[i])
    fp.write('{0: f}; {1: f}\n'.format(t[i], u[i]))

fp.close()

# Квантование сигнала

quantized_u = quantize(u, delta, n)

plt.figure()
plt.plot(t, u, label='Оригинальный сигнал')
plt.plot(t, quantized_u, 'o', color='tab:orange', label='Квантованный сигнал', markersize=5)
plt.plot(t, quantized_u, color='tab:green', label='Квантованный сигнал')
# plt.vlines(t, 0, quantized_u1, color='tab:orange', lw=1)
plt.show()

import numpy as np
from math import *
import matplotlib.pyplot as plt

def signal(x):
    return 1.0 + sin(2.0*pi*x) + 2.0 * cos(4.0*pi*x) + 0.5 * cos(6.0*pi*x)

def quantize(signal_values, delta, n):
    # Квантование сигнала на заданное количество уровней
    ampl = max(signal_values) - min(signal_values)
    quant = [0] * n
    for i in range(n):
      quant[i] = round(signal_values[i] / delta) * delta
    return quant

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
delta = float(input('Введите шаг квантования: '))

fp = open('data.csv', 'w', encoding='utf-8')

t = np.linspace(0, T, n)
u = [0] * n

fp.write('t; u\n')
for i in range(n):
    u[i] = signal(f*t[i])
    fp.write('{0: f}; {1: f}\n'.format(t[i], u[i]))

fp.close()

# Квантование сигнала

quantized_u = quantize(u, delta, n)

plt.figure()
plt.plot(t, u, label='Оригинальный сигнал')
plt.plot(t, quantized_u, 'o', color='tab:orange', label='Квантованный сигнал', markersize=5)
plt.plot(t, quantized_u, color='tab:green', label='Квантованный сигнал')
# plt.vlines(t, 0, quantized_u1, color='tab:orange', lw=1)
plt.show()

import numpy as np
from math import *
import matplotlib.pyplot as plt

def signal(x):
    return 1.0 + sin(2.0*pi*x) + 2.0 * cos(4.0*pi*x) + 0.5 * cos(6.0*pi*x)

def quantize(signal_values, delta, n):
    # Квантование сигнала на заданное количество уровней
    ampl = max(signal_values) - min(signal_values)
    quant = [0] * n
    for i in range(n):
      quant[i] = round(signal_values[i] / delta) * delta
    return quant

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
delta = float(input('Введите шаг квантования: '))

fp = open('data.csv', 'w', encoding='utf-8')

t = np.linspace(0, T, n)
u = [0] * n

fp.write('t; u\n')
for i in range(n):
    u[i] = signal(f*t[i])
    fp.write('{0: f}; {1: f}\n'.format(t[i], u[i]))

fp.close()

# Квантование сигнала

quantized_u = quantize(u, delta, n)

plt.figure()
plt.plot(t, u, label='Оригинальный сигнал')
plt.plot(t, quantized_u, 'o', color='tab:orange', label='Квантованный сигнал', markersize=5)
plt.plot(t, quantized_u, color='tab:green', label='Квантованный сигнал')
# plt.vlines(t, 0, quantized_u1, color='tab:orange', lw=1)
plt.show()
