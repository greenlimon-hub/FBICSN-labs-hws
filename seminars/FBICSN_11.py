# -*- coding: utf-8 -*-
"""описис_с11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12wMDNdy_WoWi7O4kCHkXje8qxRJHviX7

передающая сторона - задаются переносчики (первичный сигнал в канальный => мб модулятор)

без синхросигнала

канал передачи

приемник (фильтрация и демодуляция)

есть три гармонических сигнала U_s = A_s*cos(w_s*t)

U_m = A_m*cos(w_m*t), w_m - частота переносчика

Модуляция:

U_AM(t) = U_m(t)*[1 + m*U_s(t)/|U_s(t)|_max]

m<=1 - неискаженная

получаем три частотных диапазона спектра сигнала (3 несущие, у каждой по две боковые), важно, чтобы они не пересекались

3 полосовых фильтра, каждый настроен на один из трех частотных диапазонов

Получаем:

|......|.............|.........|................|..........|............|....

f_s f_m-f_s f_s f_m+f_s 2f_m-f_s 2f_m 2f_m+f_s и тд
"""

import numpy as np
import math
import matplotlib.pyplot as plt

def f2w(f):
    return 2.0*math.pi*f

def filter(time, signal, fl, fh):
    n = len(signal)
    freq = np.fft.fftfreq(n, time[1]-time[0])
    spectr = np.fft.fft(signal)
    for i in range(n):
        if not fl < abs(freq[i]) < fh:
            spectr[i] = 0+0j
    return np.fft.ifft(spectr)

fs = []
for i in range(3):
    f = float(input('Опорная частота гармонического сигнала с номером ' + str(i+1)))
    fs.append(f)
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
h = T / n

m = float(input('Глубина модуляции '))

fn = [0] * 3
for i in range(0, 3):
    fn[i] = fs[i] * 6

sig1 = [0] * n
sig2 = [0] * n
sig3 = [0] * n
time = [0] * n
tgrp = [0] * n

sam1 = [0] * n
sam2 = [0] * n
sam3 = [0] * n

#Формирование первичных сигналов в каналах на входе СП ЧРК
for i in range(n):
    time[i] = i*h
    sig1[i] = 1.0 * math.cos(f2w(fs[0])*time[i])
    sig2[i] = 2.0 * math.cos(f2w(fs[1])*time[i])
    sig3[i] = 1.5 * math.cos(f2w(fs[2])*time[i])

    sam1[i] = 1.0 * math.cos(f2w(fn[0])*time[i])
    sam2[i] = 1.0 * math.cos(f2w(fn[1])*time[i])
    sam3[i] = 1.0 * math.cos(f2w(fn[2])*time[i])

spec1 = np.fft.fft(sig1)
spec2 = np.fft.fft(sig2)
spec3 = np.fft.fft(sig3)
freq = np.fft.fftfreq(n, T/n)

#Амплитудная модуляция
for i in range(n):
    sam1[i] = sam1[i] * (1 + m * sig1[i] / 2.0)
    sam2[i] = sam2[i] * (1 + m * sig2[i] / 2.0)
    sam3[i] = sam3[i] * (1 + m * sig3[i] / 2.0)

for i in range(n):
    tgrp[i] = sam1[i] + sam2[i] + sam3[i]

spec_grp = np.fft.fft(tgrp)


#Фильтрация группового сигнала с выделением канальных сигналов
rch1 = filter(time, tgrp, fn[0]-fs[0]-2, fn[0]+fs[0]+2).real
rch2 = filter(time, tgrp, fn[1]-fs[1]-2, fn[1]+fs[1]+2).real
rch3 = filter(time, tgrp, fn[2]-fs[2]-2, fn[2]+fs[2]+2).real

mch1 = [0] * n
mch2 = [0] * n
mch3 = [0] * n
#Демодуляция канальных сигналов
for i in range(n):
    mch1[i] = (1.0 + m * math.cos(f2w(fn[0])*time[i]))*rch1[i]
    mch2[i] = (1.0 + m * math.cos(f2w(fn[1])*time[i]))*rch2[i]
    mch3[i] = (1.0 + m * math.cos(f2w(fn[2])*time[i]))*rch3[i]

#Канальные ФНЧ для выделения первичных сигналов
rsig1 = filter(time, mch1, 1, fs[2]+1).real
rsig2 = filter(time, mch2, 1, fs[2]+1).real
rsig3 = filter(time, mch3, 1, fs[2]+1).real

plt.figure(figsize = (15, 10))
plt.subplot(3, 3, 1)
plt.title('Первичные сигналы')
plt.plot(time, sig1)
plt.plot(time, sig2)
plt.plot(time, sig3)
plt.subplot(3, 3, 2)
plt.title('Групповой сигнал')
plt.plot(time, tgrp)
plt.subplot(3, 3, 3)
plt.title('Спектры сигналов на входе')
plt.xlim(left = 0, right = fs[2]*1.5)
plt.plot(freq, np.hypot(spec1.real, spec1.imag)/n*2.0)
plt.plot(freq, np.hypot(spec2.real, spec2.imag)/n*2.0)
plt.plot(freq, np.hypot(spec3.real, spec3.imag)/n*2.0)
plt.subplot(3, 3, 4)
plt.title('Спектр группового сигнала')
plt.xlim(left = 0, right = fn[2]*1.5)
plt.plot(freq, np.hypot(spec_grp.real, spec_grp.imag)/n*2.0)
plt.subplot(3, 3, 5)
plt.title('Фильтрация графппового сигнала с выделением канальных сигналов')
plt.plot(time, rch1)
plt.plot(time, rch2)
plt.plot(time, rch3)
plt.subplot(3, 3, 6)
plt.title('Демодуляция канальных сигналов')
plt.plot(time, mch1)
plt.plot(time, mch2)
plt.plot(time, mch3)
plt.subplot(3, 3, 7)
plt.title('Спектр демодулированных канальных сигналов')
spec_dam1 = np.fft.fft(mch1)
spec_dam2 = np.fft.fft(mch2)
spec_dam3 = np.fft.fft(mch3)
plt.plot(freq, np.hypot(spec_dam1.real, spec_dam1.imag)/n*2.0)
plt.plot(freq, np.hypot(spec_dam2.real, spec_dam2.imag)/n*2.0)
plt.plot(freq, np.hypot(spec_dam3.real, spec_dam3.imag)/n*2.0)
plt.subplot(3, 3, 8)
plt.plot(time, rsig1)
plt.plot(time, rsig2)
plt.plot(time, rsig3)
plt.show()

import numpy as np
import math
import matplotlib.pyplot as plt

def f2w(f):
    return 2.0*math.pi*f

def filter(time, signal, fl, fh):
    n = len(signal)
    freq = np.fft.fftfreq(n, time[1]-time[0])
    spectr = np.fft.fft(signal)
    for i in range(n):
        if not fl < abs(freq[i]) < fh:
            spectr[i] = 0+0j
    return np.fft.ifft(spectr)

fs = []
for i in range(3):
    f = float(input('Опорная частота гармонического сигнала с номером ' + str(i+1)))
    fs.append(f)
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
h = T / n

m = float(input('Глубина модуляции '))

fn = [0] * 3
for i in range(0, 3):
    fn[i] = fs[i] * 6

sig1 = [0] * n
sig2 = [0] * n
sig3 = [0] * n
time = [0] * n
tgrp = [0] * n

sam1 = [0] * n
sam2 = [0] * n
sam3 = [0] * n

#Формирование первичных сигналов в каналах на входе СП ЧРК
for i in range(n):
    time[i] = i*h
    sig1[i] = 1.0 * math.cos(f2w(fs[0])*time[i])
    sig2[i] = 2.0 * math.cos(f2w(fs[1])*time[i])
    sig3[i] = 1.5 * math.cos(f2w(fs[2])*time[i])

    sam1[i] = 1.0 * math.cos(f2w(fn[0])*time[i])
    sam2[i] = 1.0 * math.cos(f2w(fn[1])*time[i])
    sam3[i] = 1.0 * math.cos(f2w(fn[2])*time[i])

spec1 = np.fft.fft(sig1)
spec2 = np.fft.fft(sig2)
spec3 = np.fft.fft(sig3)
freq = np.fft.fftfreq(n, T/n)

#Амплитудная модуляция
for i in range(n):
    sam1[i] = sam1[i] * (1 + m * sig1[i] / 2.0)
    sam2[i] = sam2[i] * (1 + m * sig2[i] / 2.0)
    sam3[i] = sam3[i] * (1 + m * sig3[i] / 2.0)

for i in range(n):
    tgrp[i] = sam1[i] + sam2[i] + sam3[i]

spec_grp = np.fft.fft(tgrp)


#Фильтрация группового сигнала с выделением канальных сигналов
rch1 = filter(time, tgrp, fn[0]-fs[0]-2, fn[0]+fs[0]+2).real
rch2 = filter(time, tgrp, fn[1]-fs[1]-2, fn[1]+fs[1]+2).real
rch3 = filter(time, tgrp, fn[2]-fs[2]-2, fn[2]+fs[2]+2).real

mch1 = [0] * n
mch2 = [0] * n
mch3 = [0] * n
#Демодуляция канальных сигналов
for i in range(n):
    mch1[i] = (1.0 + m * math.cos(f2w(fn[0])*time[i]))*rch1[i]
    mch2[i] = (1.0 + m * math.cos(f2w(fn[1])*time[i]))*rch2[i]
    mch3[i] = (1.0 + m * math.cos(f2w(fn[2])*time[i]))*rch3[i]

#Канальные ФНЧ для выделения первичных сигналов
rsig1 = filter(time, mch1, 1, fs[2]+1).real
rsig2 = filter(time, mch2, 1, fs[2]+1).real
rsig3 = filter(time, mch3, 1, fs[2]+1).real

plt.figure(figsize = (15, 10))
plt.subplot(3, 3, 1)
plt.title('Первичные сигналы')
plt.plot(time, sig1)
plt.plot(time, sig2)
plt.plot(time, sig3)
plt.subplot(3, 3, 2)
plt.title('Групповой сигнал')
plt.plot(time, tgrp)
plt.subplot(3, 3, 3)
plt.title('Спектры сигналов на входе')
plt.xlim(left = 0, right = fs[2]*1.5)
plt.plot(freq, np.hypot(spec1.real, spec1.imag)/n*2.0)
plt.plot(freq, np.hypot(spec2.real, spec2.imag)/n*2.0)
plt.plot(freq, np.hypot(spec3.real, spec3.imag)/n*2.0)
plt.subplot(3, 3, 4)
plt.title('Спектр группового сигнала')
plt.xlim(left = 0, right = fn[2]*1.5)
plt.plot(freq, np.hypot(spec_grp.real, spec_grp.imag)/n*2.0)
plt.subplot(3, 3, 5)
plt.title('Фильтрация графппового сигнала с выделением канальных сигналов')
plt.plot(time, rch1)
plt.plot(time, rch2)
plt.plot(time, rch3)
plt.subplot(3, 3, 6)
plt.title('Демодуляция канальных сигналов')
plt.plot(time, mch1)
plt.plot(time, mch2)
plt.plot(time, mch3)
plt.subplot(3, 3, 7)
plt.title('Спектр демодулированных канальных сигналов')
spec_dam1 = np.fft.fft(mch1)
spec_dam2 = np.fft.fft(mch2)
spec_dam3 = np.fft.fft(mch3)
plt.plot(freq, np.hypot(spec_dam1.real, spec_dam1.imag)/n*2.0)
plt.plot(freq, np.hypot(spec_dam2.real, spec_dam2.imag)/n*2.0)
plt.plot(freq, np.hypot(spec_dam3.real, spec_dam3.imag)/n*2.0)
plt.subplot(3, 3, 8)
plt.plot(time, rsig1)
plt.plot(time, rsig2)
plt.plot(time, rsig3)
plt.show()

import numpy as np
import math
import matplotlib.pyplot as plt

# Определение функций (оставляем без изменений)
def f2w(f):
    return 2.0 * math.pi * f

def filter(time, signal, fl, fh):
    n = len(signal)
    freq = np.fft.fftfreq(n, time[1] - time[0])
    spectr = np.fft.fft(signal)
    for i in range(n):
        if not fl < abs(freq[i]) < fh:
            spectr[i] = 0 + 0j
    return np.fft.ifft(spectr)

# Функция влияния линии передачи (добавляем из вашего запроса)
def transmission_line_effect(eta, fc, Tc, fl, fh, f0, Z0, Nc):
    L = (np.sqrt(Z0**2 * f2w(f0)**2 * (2 * f2w(fh)**2 - f2w(fl)**2 - f2w(f0)**2) /
         ((f2w(fh)**2 - f2w(fl)**2)**2 * (f2w(f0)**2 - f2w(fl)**2))))
    C1 = 1.0 / L / (f2w(fh)**2 - f2w(fl)**2)
    C2 = 1.0 / (f2w(fl)**2 * L)
    G = 0

    print('Параметры отдельной ячейки ЛП:')
    print('C1 = {0: f}\nC2 = {1: f}\nL = {2: f}'.format(C1, C2, L))

    npp = 10            # Количество точек на период гармонического сигнала
    dt = 1 / (fc * npp) # Шаг по времени
    num = int(Tc / dt)  # Количество временных отсчетов

    freq = np.linspace(0.8 * fl, fh * 1.2, num)

    # Задание производной сигнала возбуждения ЛП
    d_signal = lambda t: -np.sin(2 * np.pi * fc * t)

    A0 = 1  # Амплитуда сигнала слева
    AN = 0  # Амплитуда сигнала справа
    K0 = KN = 1  # Коэффициенты при нагрузочных сопротивлениях

    # Количество итераций для решения уравнений возбуждения
    dpp = 20
    print('dpp = {0: d}'.format(dpp))

    aU = [0] * Nc     # Массив напряжений на емкости C2
    dU = [0] * Nc     # Массив производных напряжений на емкости C2
    aV = [0] * (Nc + 1) # Массив напряжений на емкости C1
    dV = [0] * (Nc + 1) # Массив производных напряжений на емкости C1

    Vinp_tl = [0] * num  # Массив входных напряжений
    Vout_tl = [0] * num  # Массив выходных напряжений
    time = [0] * num  # Массив временных отсчетов

    Vs = [0] * npp    # Массив напряжений на C1 вдоль ЛП на одном периоде сигнала
    for i in range(npp): Vs[i] = [0] * (Nc + 1)

    # Решение уравнений возбуждения ЛП
    for it in range(num):
        time[it] = dt * it
        for i in range(dpp):
            dV[0] += (1.0 / (L * C1) * (aV[1] - aV[0] + aU[0]) + 1.0 / (Z0 * K0 * C1) * (A0 * d_signal(time[it]) - dV[0])) * dt / dpp
            for ic in range(Nc):
                dU[ic] += (1.0 / (L * C2) * (aV[ic] - aV[ic + 1] - aU[ic]) - G / C2 * dU[ic]) * dt / dpp
                if ic == 0: continue
                dV[ic] += (0.5 / (L * C1) * (aV[ic - 1] - 2.0 * aV[ic] + aV[ic + 1] + aU[ic] - aU[ic - 1])) * dt / dpp
            dV[Nc] += (1.0 / (L * C1) * (aV[Nc - 1] - aV[Nc] - aU[Nc - 1]) + 1.0 / (Z0 * KN * C1) * (AN * d_signal(time[it]) - dV[Nc])) * dt / dpp

            for ic in range(Nc):
                aV[ic] += dV[ic] * dt / dpp
                aU[ic] += dU[ic] * dt / dpp
            aV[Nc] += dV[Nc] * dt / dpp

        if num - it <= npp:
            for ic in range(Nc + 1):
                Vs[it - (num - npp)][ic] = aV[ic]

        Vinp_tl[it] = aV[0]
        Vout_tl[it] = aV[Nc]
        if it % 100 == 0:
            print('{0: 7.3f} {1: 7.3f} {2: 7.3f} '.format(time[it], Vinp_tl[it], Vout_tl[it]))

    Vinp_0 = [0] * num
    Vout_0 = [0] * num

    for it in range(num):
        Vinp_0[it] = Vinp_tl[it] * (1 + eta)
        Vout_0[it] = Vout_tl[it] / (1 + 1 / eta)

    return Vinp_0, Vout_0

# Основная часть программы
fs = []
for i in range(3):
    f = float(input('Опорная частота гармонического сигнала с номером ' + str(i + 1) + ': '))
    fs.append(f)
T = float(input('Временной интервал: '))
n = int(input('Число временных отсчетов: '))
h = T / n

m = float(input('Глубина модуляции: '))

fn = [0] * 3
for i in range(0, 3):
    fn[i] = fs[i] * 6

sig1 = [0] * n
sig2 = [0] * n
sig3 = [0] * n
time = [0] * n
tgrp = [0] * n

sam1 = [0] * n
sam2 = [0] * n
sam3 = [0] * n

# Формирование первичных сигналов в каналах на входе СП ЧРК
for i in range(n):
    time[i] = i * h
    sig1[i] = 1.0 * math.cos(f2w(fs[0]) * time[i])
    sig2[i] = 2.0 * math.cos(f2w(fs[1]) * time[i])
    sig3[i] = 1.5 * math.cos(f2w(fs[2]) * time[i])

    sam1[i] = 1.0 * math.cos(f2w(fn[0]) * time[i])
    sam2[i] = 1.0 * math.cos(f2w(fn[1]) * time[i])
    sam3[i] = 1.0 * math.cos(f2w(fn[2]) * time[i])

spec1 = np.fft.fft(sig1)
spec2 = np.fft.fft(sig2)
spec3 = np.fft.fft(sig3)
freq = np.fft.fftfreq(n, T / n)

# Амплитудная модуляция
for i in range(n):
    sam1[i] = sam1[i] * (1 + m * sig1[i] / 2.0)
    sam2[i] = sam2[i] * (1 + m * sig2[i] / 2.0)
    sam3[i] = sam3[i] * (1 + m * sig3[i] / 2.0)

for i in range(n):
    tgrp[i] = sam1[i] + sam2[i] + sam3[i]

spec_grp = np.fft.fft(tgrp)

# Применение функции влияния линии передачи
eta = 1.0  # Коэффициент неравноплечности
fc = max(fn)  # Центральная частота
fl = min(fn) - fs[0] - 2  # Нижняя граница полосы пропускания
fh = max(fn) + fs[2] + 2  # Верхняя граница полосы пропускания
f0 = (fl + fh) / 2  # Центральная частота для расчета параметров линии
Z0 = 50  # Характеристическое сопротивление
Nc = 10  # Количество ячеек в линии передачи

Vinp_0, Vout_0 = transmission_line_effect(eta, fc, T, fl, fh, f0, Z0, Nc)

# Добавление искаженного сигнала в массив данных
tgrp_distorted = Vout_0[:n]

# Обновление фильтрации и демодуляции с учетом искаженного сигнала
rch1_distorted = filter(time, tgrp_distorted, fn[0] - fs[0] - 2, fn[0] + fs[0] + 2).real
rch2_distorted = filter(time, tgrp_distorted, fn[1] - fs[1] - 2, fn[1] + fs[1] + 2).real
rch3_distorted = filter(time, tgrp_distorted, fn[2] - fs[2] - 2, fn[2] + fs[2] + 2).real

mch1_distorted = [0] * n
mch2_distorted = [0] * n
mch3_distorted = [0] * n
for i in range(n):
    mch1_distorted[i] = (1.0 + m * math.cos(f2w(fn[0]) * time[i])) * rch1_distorted[i]
    mch2_distorted[i] = (1.0 + m * math.cos(f2w(fn[1]) * time[i])) * rch2_distorted[i]
    mch3_distorted[i] = (1.0 + m * math.cos(f2w(fn[2]) * time[i])) * rch3_distorted[i]

rsig1_distorted = filter(time, mch1_distorted, 1, fs[2] + 1).real
rsig2_distorted = filter(time, mch2_distorted, 1, fs[2] + 1).real
rsig3_distorted = filter(time, mch3_distorted, 1, fs[2] + 1).real

# Построение графиков
plt.figure(figsize = (15, 10))
plt.subplot(3, 3, 1)
plt.title('Первичные сигналы')
plt.plot(time, sig1)
plt.plot(time, sig2)
plt.plot(time, sig3)
plt.subplot(3, 3, 2)
plt.title('Групповой сигнал')
plt.plot(time, tgrp)
plt.subplot(3, 3, 3)
plt.title('Спектры сигналов на входе')
plt.xlim(left = 0, right = fs[2]*1.5)
plt.plot(freq, np.hypot(spec1.real, spec1.imag)/n*2.0)
plt.plot(freq, np.hypot(spec2.real, spec2.imag)/n*2.0)
plt.plot(freq, np.hypot(spec3.real, spec3.imag)/n*2.0)
plt.subplot(3, 3, 4)
plt.title('Спектр группового сигнала')
plt.xlim(left = 0, right = fn[2]*1.5)
plt.plot(freq, np.hypot(spec_grp.real, spec_grp.imag)/n*2.0)
plt.subplot(3, 3, 5)
plt.title('Групповой сигнал после ЛП')
plt.plot(time, tgrp_distorted)
plt.plot(time, Vinp_0[:n])
plt.subplot(3, 3, 6)
plt.title('Фильтрация графппового сигнала с выделением канальных сигналов')
plt.plot(time, rch1)
plt.plot(time, rch2)
plt.plot(time, rch3)
plt.subplot(3, 3, 7)
plt.title('Демодуляция канальных сигналов')
plt.plot(time, mch1)
plt.plot(time, mch2)
plt.plot(time, mch3)
plt.subplot(3, 3, 8)
plt.title('Спектр демодулированных канальных сигналов')
spec_dam1 = np.fft.fft(mch1)
spec_dam2 = np.fft.fft(mch2)
spec_dam3 = np.fft.fft(mch3)
plt.plot(freq, np.hypot(spec_dam1.real, spec_dam1.imag)/n*2.0)
plt.plot(freq, np.hypot(spec_dam2.real, spec_dam2.imag)/n*2.0)
plt.plot(freq, np.hypot(spec_dam3.real, spec_dam3.imag)/n*2.0)
plt.subplot(3, 3, 9)
plt.plot(time, rsig1)
plt.plot(time, rsig2)
plt.plot(time, rsig3)
plt.show()

import numpy as np
import math
import matplotlib.pyplot as plt

# Определение функций (оставляем без изменений)
def f2w(f):
    return 2.0 * math.pi * f

def filter(time, signal, fl, fh):
    n = len(signal)
    freq = np.fft.fftfreq(n, time[1] - time[0])
    spectr = np.fft.fft(signal)
    for i in range(n):
        if not fl < abs(freq[i]) < fh:
            spectr[i] = 0 + 0j
    return np.fft.ifft(spectr)

# Функция влияния линии передачи (добавляем из вашего запроса)
def transmission_line_effect(eta, fc, Tc, fl, fh, f0, Z0, Nc):
    L = (np.sqrt(Z0**2 * f2w(f0)**2 * (2 * f2w(fh)**2 - f2w(fl)**2 - f2w(f0)**2) /
         ((f2w(fh)**2 - f2w(fl)**2)**2 * (f2w(f0)**2 - f2w(fl)**2))))
    C1 = 1.0 / L / (f2w(fh)**2 - f2w(fl)**2)
    C2 = 1.0 / (f2w(fl)**2 * L)
    G = 0

    print('Параметры отдельной ячейки ЛП:')
    print('C1 = {0: f}\nC2 = {1: f}\nL = {2: f}'.format(C1, C2, L))

    npp = 10            # Количество точек на период гармонического сигнала
    dt = 1 / (fc * npp) # Шаг по времени
    num = int(Tc / dt)  # Количество временных отсчетов

    freq = np.linspace(0.8 * fl, fh * 1.2, num)

    # Задание производной сигнала возбуждения ЛП
    d_signal = lambda t: -np.sin(2 * np.pi * fc * t)

    A0 = 1  # Амплитуда сигнала слева
    AN = 0  # Амплитуда сигнала справа
    K0 = KN = 1  # Коэффициенты при нагрузочных сопротивлениях

    # Количество итераций для решения уравнений возбуждения
    dpp = 20
    print('dpp = {0: d}'.format(dpp))

    aU = [0] * Nc     # Массив напряжений на емкости C2
    dU = [0] * Nc     # Массив производных напряжений на емкости C2
    aV = [0] * (Nc + 1) # Массив напряжений на емкости C1
    dV = [0] * (Nc + 1) # Массив производных напряжений на емкости C1

    Vinp_tl = [0] * num  # Массив входных напряжений
    Vout_tl = [0] * num  # Массив выходных напряжений
    time = [0] * num  # Массив временных отсчетов

    Vs = [0] * npp    # Массив напряжений на C1 вдоль ЛП на одном периоде сигнала
    for i in range(npp): Vs[i] = [0] * (Nc + 1)

    # Решение уравнений возбуждения ЛП
    for it in range(num):
        time[it] = dt * it
        for i in range(dpp):
            dV[0] += (1.0 / (L * C1) * (aV[1] - aV[0] + aU[0]) + 1.0 / (Z0 * K0 * C1) * (A0 * d_signal(time[it]) - dV[0])) * dt / dpp
            for ic in range(Nc):
                dU[ic] += (1.0 / (L * C2) * (aV[ic] - aV[ic + 1] - aU[ic]) - G / C2 * dU[ic]) * dt / dpp
                if ic == 0: continue
                dV[ic] += (0.5 / (L * C1) * (aV[ic - 1] - 2.0 * aV[ic] + aV[ic + 1] + aU[ic] - aU[ic - 1])) * dt / dpp
            dV[Nc] += (1.0 / (L * C1) * (aV[Nc - 1] - aV[Nc] - aU[Nc - 1]) + 1.0 / (Z0 * KN * C1) * (AN * d_signal(time[it]) - dV[Nc])) * dt / dpp

            for ic in range(Nc):
                aV[ic] += dV[ic] * dt / dpp
                aU[ic] += dU[ic] * dt / dpp
            aV[Nc] += dV[Nc] * dt / dpp

        if num - it <= npp:
            for ic in range(Nc + 1):
                Vs[it - (num - npp)][ic] = aV[ic]

        Vinp_tl[it] = aV[0]
        Vout_tl[it] = aV[Nc]
        if it % 100 == 0:
            print('{0: 7.3f} {1: 7.3f} {2: 7.3f} '.format(time[it], Vinp_tl[it], Vout_tl[it]))

    Vinp_0 = [0] * num
    Vout_0 = [0] * num

    for it in range(num):
        Vinp_0[it] = Vinp_tl[it] * (1 + eta)
        Vout_0[it] = Vout_tl[it] / (1 + 1 / eta)

    return Vinp_0, Vout_0

# Основная часть программы
fs = []
for i in range(3):
    f = float(input('Опорная частота гармонического сигнала с номером ' + str(i + 1) + ': '))
    fs.append(f)
T = float(input('Временной интервал: '))
n = int(input('Число временных отсчетов: '))
h = T / n

m = float(input('Глубина модуляции: '))

fn = [0] * 3
for i in range(0, 3):
    fn[i] = fs[i] * 6

sig1 = [0] * n
sig2 = [0] * n
sig3 = [0] * n
time = [0] * n
tgrp = [0] * n

sam1 = [0] * n
sam2 = [0] * n
sam3 = [0] * n

# Формирование первичных сигналов в каналах на входе СП ЧРК
for i in range(n):
    time[i] = i * h
    sig1[i] = 1.0 * math.cos(f2w(fs[0]) * time[i])
    sig2[i] = 2.0 * math.cos(f2w(fs[1]) * time[i])
    sig3[i] = 1.5 * math.cos(f2w(fs[2]) * time[i])

    sam1[i] = 1.0 * math.cos(f2w(fn[0]) * time[i])
    sam2[i] = 1.0 * math.cos(f2w(fn[1]) * time[i])
    sam3[i] = 1.0 * math.cos(f2w(fn[2]) * time[i])

spec1 = np.fft.fft(sig1)
spec2 = np.fft.fft(sig2)
spec3 = np.fft.fft(sig3)
freq = np.fft.fftfreq(n, T / n)

# Амплитудная модуляция
for i in range(n):
    sam1[i] = sam1[i] * (1 + m * sig1[i] / 2.0)
    sam2[i] = sam2[i] * (1 + m * sig2[i] / 2.0)
    sam3[i] = sam3[i] * (1 + m * sig3[i] / 2.0)

for i in range(n):
    tgrp[i] = sam1[i] + sam2[i] + sam3[i]

spec_grp = np.fft.fft(tgrp)

# Применение функции влияния линии передачи
eta = 1.0  # Коэффициент неравноплечности
fc = max(fn)  # Центральная частота
fl = min(fn) - fs[0] - 2  # Нижняя граница полосы пропускания
fh = max(fn) + fs[2] + 2  # Верхняя граница полосы пропускания
f0 = (fl + fh) / 2  # Центральная частота для расчета параметров линии
Z0 = 50  # Характеристическое сопротивление
Nc = 10  # Количество ячеек в линии передачи

Vinp_0, Vout_0 = transmission_line_effect(eta, fc, T, fl, fh, f0, Z0, Nc)

# Добавление искаженного сигнала в массив данных
tgrp_distorted = Vout_0[:n]

# Обновление фильтрации и демодуляции с учетом искаженного сигнала
rch1_distorted = filter(time, tgrp_distorted, fn[0] - fs[0] - 2, fn[0] + fs[0] + 2).real
rch2_distorted = filter(time, tgrp_distorted, fn[1] - fs[1] - 2, fn[1] + fs[1] + 2).real
rch3_distorted = filter(time, tgrp_distorted, fn[2] - fs[2] - 2, fn[2] + fs[2] + 2).real

mch1_distorted = [0] * n
mch2_distorted = [0] * n
mch3_distorted = [0] * n
for i in range(n):
    mch1_distorted[i] = (1.0 + m * math.cos(f2w(fn[0]) * time[i])) * rch1_distorted[i]
    mch2_distorted[i] = (1.0 + m * math.cos(f2w(fn[1]) * time[i])) * rch2_distorted[i]
    mch3_distorted[i] = (1.0 + m * math.cos(f2w(fn[2]) * time[i])) * rch3_distorted[i]

rsig1_distorted = filter(time, mch1_distorted, 1, fs[2] + 1).real
rsig2_distorted = filter(time, mch2_distorted, 1, fs[2] + 1).real
rsig3_distorted = filter(time, mch3_distorted, 1, fs[2] + 1).real

# Построение графиков
plt.figure(figsize = (15, 10))
plt.subplot(3, 3, 1)
plt.title('Первичные сигналы')
plt.plot(time, sig1)
plt.plot(time, sig2)
plt.plot(time, sig3)
plt.subplot(3, 3, 2)
plt.title('Групповой сигнал')
plt.plot(time, tgrp)
plt.subplot(3, 3, 3)
plt.title('Спектры сигналов на входе')
plt.xlim(left = 0, right = fs[2]*1.5)
plt.plot(freq, np.hypot(spec1.real, spec1.imag)/n*2.0)
plt.plot(freq, np.hypot(spec2.real, spec2.imag)/n*2.0)
plt.plot(freq, np.hypot(spec3.real, spec3.imag)/n*2.0)
plt.subplot(3, 3, 4)
plt.title('Спектр группового сигнала')
plt.xlim(left = 0, right = fn[2]*1.5)
plt.plot(freq, np.hypot(spec_grp.real, spec_grp.imag)/n*2.0)
plt.subplot(3, 3, 5)
plt.title('Групповой сигнал после ЛП')
plt.plot(time, tgrp_distorted)
plt.plot(time, Vinp_0[:n])
plt.subplot(3, 3, 6)
plt.title('Фильтрация графппового сигнала с выделением канальных сигналов')
plt.plot(time, rch1)
plt.plot(time, rch2)
plt.plot(time, rch3)
plt.subplot(3, 3, 7)
plt.title('Демодуляция канальных сигналов')
plt.plot(time, mch1)
plt.plot(time, mch2)
plt.plot(time, mch3)
plt.subplot(3, 3, 8)
plt.title('Спектр демодулированных канальных сигналов')
spec_dam1 = np.fft.fft(mch1)
spec_dam2 = np.fft.fft(mch2)
spec_dam3 = np.fft.fft(mch3)
plt.plot(freq, np.hypot(spec_dam1.real, spec_dam1.imag)/n*2.0)
plt.plot(freq, np.hypot(spec_dam2.real, spec_dam2.imag)/n*2.0)
plt.plot(freq, np.hypot(spec_dam3.real, spec_dam3.imag)/n*2.0)
plt.subplot(3, 3, 9)
plt.plot(time, rsig1)
plt.plot(time, rsig2)
plt.plot(time, rsig3)
plt.show()

"""что-то про решение производной d(grp)/dt, V_out и блаблабла - линия передачи"""