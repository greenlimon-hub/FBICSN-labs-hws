# -*- coding: utf-8 -*-
"""описис_06.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EDfcPqljWlpWZYCR6k7P0AbQQfaEvu9b
"""

import numpy as np
from math import *
import matplotlib.pyplot as plt

def signal1(x):
    return 1.0 + sin(2.0*pi*x) + 2.0 * cos(4.0*pi*x) + 0.5 * cos(6.0*pi*x)

def signal2(x):
    return (1.0 * np.exp(-Gam(0.001, L, C1, C2).real) + sin(2.0*pi*x) * np.exp(-Gam(f, L, C1, C2).real) +
            2.0 * cos(4.0*pi*x) * np.exp(-Gam(2.0*f, L, C1, C2).real) +
            0.5 * cos(6.0*pi*x) * np.exp(-Gam(3.0*f, L, C1, C2).real))

def f2w(f):
    return 2.0*pi*f

def Z1(f, C1):
    return 2.0/(1j*f2w(f)*C1)

def Z2 (f, C2):
    return 1.0/(1j*f2w(f)*C2)

def Z3(f, L):
    return 1.0j*f2w(f)*L

def Gam(f, L, C1, C2):
    ZY = (Z2(f, C2)+Z3(f, L))/Z1(f, C1)
    return 2.0 * np.arcsinh(np.sqrt(ZY))

def Zw_func(f, L, C1, C2):
    return np.sqrt((Z1(f, C1)**2*(Z2(f, C2)+Z3(f, L)))/(2*Z1(f, C1)+Z2(f, C2)+Z3(f, L)))

"""Рассчитать частотные и фазовые характеристики полосового фильтра для двух различных характеристических сопротивлений четырехполюсника."""

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

fl = float(input('Нижняя граничная частота фильтра '))
fh = float(input('Верхняя граничная частота фильтра '))
f0 = (fl + fh) * 0.5
Z0 = float(input('Характеристическое сопротивление фильтра на частоте '+str(f0)+' '))

L = (sqrt(Z0**2*f2w(f0)**2*(2*f2w(fh)**2-f2w(fl)**2-f2w(f0)**2)/
    ((f2w(fh)**2-f2w(fl)**2)**2*(f2w(f0)**2-f2w(fl)**2))))
C1 = 2.0 / L / (f2w(fh)**2 - f2w(fl)**2)
C2 = 1.0 / (f2w(fl)**2 * L)

print('Параметры фильтра:')
print('C1 = {0: f}\nC2 = {1: f}\nL = {2: f}'.format(C1, C2, L))

freq = np.linspace(0.8*fl, fh*1.2, n)

Gama = Gam(freq, L, C1, C2)
Zw = Zw_func(freq, L, C1, C2)
dF = (Gam(freq+0.01, L, C1, C2).imag-Gam(freq-0.01, L, C1, C2).imag) / 0.02

plt.figure()
plt.plot(freq, Gama.real, color='tab:blue', label=r'$\alpha(f)$')
plt.tick_params(axis='y', labelcolor='tab:blue')
plt.legend(loc='lower right')
plt.twinx()
plt.plot(freq, Gama.imag, color='tab:orange', label=r'$\phi(f)$')
plt.tick_params(axis='y', labelcolor='tab:orange')
plt.legend(loc='upper left')
plt.show()

plt.figure()
plt.plot(freq, abs(Zw), label='$|Z_0|(f)$')
plt.plot(freq, Zw.real, label='$Re(Z_0)(f)$')
plt.plot(freq, Zw.imag, label='$Im(Z_0)(f)$')
plt.vlines(f0, 0, Z0, color='tab:olive', linestyles='dashdot', lw=1)
plt.hlines(Z0, freq[0], f, color='tab:olive', linestyles='dashdot', lw=1)
plt.legend(loc='best')
plt.show()

plt.figure()
plt.plot(freq, dF)
plt.show()

t = np.linspace(0, T, n)
uinp = [0] * n
uout = [0] * n
for i in range(n):
    uinp[i] = signal1(f*t[i])
    uout[i] = signal2(f*t[i])
plt.figure()
plt.plot(t, uinp, t, np.array(uout, dtype=complex).real)
plt.show()

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

fl = float(input('Нижняя граничная частота фильтра '))
fh = float(input('Верхняя граничная частота фильтра '))
f0 = (fl + fh) * 0.5
Z0 = float(input('Характеристическое сопротивление фильтра на частоте '+str(f0)+' '))

L = (sqrt(Z0**2*f2w(f0)**2*(2*f2w(fh)**2-f2w(fl)**2-f2w(f0)**2)/
    ((f2w(fh)**2-f2w(fl)**2)**2*(f2w(f0)**2-f2w(fl)**2))))
C1 = 2.0 / L / (f2w(fh)**2 - f2w(fl)**2)
C2 = 1.0 / (f2w(fl)**2 * L)

print('Параметры фильтра:')
print('C1 = {0: f}\nC2 = {1: f}\nL = {2: f}'.format(C1, C2, L))

freq = np.linspace(0.8*fl, fh*1.2, n)

Gama = Gam(freq, L, C1, C2)
Zw = Zw_func(freq, L, C1, C2)
dF = (Gam(freq+0.01, L, C1, C2).imag-Gam(freq-0.01, L, C1, C2).imag) / 0.02

plt.figure()
plt.plot(freq, Gama.real, color='tab:blue', label=r'$\alpha(f)$')
plt.tick_params(axis='y', labelcolor='tab:blue')
plt.legend(loc='lower right')
plt.twinx()
plt.plot(freq, Gama.imag, color='tab:orange', label=r'$\phi(f)$')
plt.tick_params(axis='y', labelcolor='tab:orange')
plt.legend(loc='upper left')
plt.show()

plt.figure()
plt.plot(freq, abs(Zw), label='$|Z_0|(f)$')
plt.plot(freq, Zw.real, label='$Re(Z_0)(f)$')
plt.plot(freq, Zw.imag, label='$Im(Z_0)(f)$')
plt.vlines(f0, 0, Z0, color='tab:olive', linestyles='dashdot', lw=1)
plt.hlines(Z0, freq[0], f, color='tab:olive', linestyles='dashdot', lw=1)
plt.legend(loc='best')
plt.show()

plt.figure()
plt.plot(freq, dF)
plt.show()

t = np.linspace(0, T, n)
uinp = [0] * n
uout = [0] * n
for i in range(n):
    uinp[i] = signal1(f*t[i])
    uout[i] = signal2(f*t[i])
plt.figure()
plt.plot(t, uinp, t, np.array(uout, dtype=complex).real)
plt.show()

"""Рассчитать частотные и фазовые характеристики фильтра низких частот Т-типа для 2 различных характеристических сопротивлений четырехполюсника. Расчеты проводить для фильтра, рассматриваемого в задании практического занятия 5."""

def calculate_filter_params(Z0, fl, fh):
    f0 = (fl + fh) * 0.5
    w0 = f2w(f0)
    wl = f2w(fl)
    wh = f2w(fh)

    # Расчет индуктивности L
    L = sqrt(Z0**2 * w0**2 * (2*wh**2 - wl**2 - w0**2) /
             ((wh**2 - wl**2)**2 * (w0**2 - wl**2)))

    # Расчет емкостей C1 и C2
    C1 = 2.0 / L / (wh**2 - wl**2)
    C2 = 1.0 / (wl**2 * L)

    return L, C1, C2

def signal1(x):
    return 1.0 + sin(2.0*pi*x) + 2.0 * cos(4.0*pi*x) + 0.5 * cos(6.0*pi*x)

def signal2(x):
    return (1.0 * np.exp(-Gam(0.001, L, C1, C2).real) + sin(2.0*pi*x) * np.exp(-Gam(f, L, C1, C2).real) +
            2.0 * cos(4.0*pi*x) * np.exp(-Gam(2.0*f, L, C1, C2).real) +
            0.5 * cos(6.0*pi*x) * np.exp(-Gam(3.0*f, L, C1, C2).real))

def f2w(f):
    return 2.0*pi*f

def Z1(f, C1):
    return 2.0/(1j*f2w(f)*C1)

def Z2 (f, C2):
    return 1.0/(1j*f2w(f)*C2)

def Z3(f, L):
    return 1.0j*f2w(f)*L

def Gam(f, L, C1, C2):
    ZY = (Z2(f, C2)+Z3(f, L))/Z1(f, C1)
    return 2.0 * np.arcsinh(np.sqrt(ZY))

def Zw(f, L, C1, C2):
    return np.sqrt((Z1(f, C1)**2*(Z2(f, C2)+Z3(f, L)))/(2*Z1(f, C1)+Z2(f, C2)+Z3(f, L)))

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

fl = float(input('Нижняя граничная частота фильтра '))
fh = float(input('Верхняя граничная частота фильтра '))
f0 = (fl + fh) * 0.5
Z0 = float(input('Характеристическое сопротивление фильтра на частоте '+str(f0)+' '))

L, C1, C2 = calculate_filter_params(Z0, fl, fh)

print('Параметры фильтра:')
print('C1 = {0: f}\nC2 = {1: f}\nL = {2: f}'.format(C1, C2, L))

freq = np.linspace(0.8*fl, fh*1.2, n)

Gama = Gam(freq, L, C1, C2)
Zw = Zw_func(freq, L, C1, C2)
dF = (Gam(freq+0.01, L, C1, C2).imag-Gam(freq-0.01, L, C1, C2).imag) / 0.02

plt.figure()
plt.plot(freq, Gama.real, color='tab:blue', label=r'$\alpha(f)$')
plt.tick_params(axis='y', labelcolor='tab:blue')
plt.legend(loc='lower right')
plt.twinx()
plt.plot(freq, Gama.imag, color='tab:orange', label=r'$\phi(f)$')
plt.tick_params(axis='y', labelcolor='tab:orange')
plt.legend(loc='upper left')
plt.show()

plt.figure()
plt.plot(freq, abs(Zw), label='$|Z_0|(f)$')
plt.plot(freq, Zw.real, label='$Re(Z_0)(f)$')
plt.plot(freq, Zw.imag, label='$Im(Z_0)(f)$')
plt.vlines(f0, 0, Z0, color='tab:olive', linestyles='dashdot', lw=1)
plt.hlines(Z0, freq[0], f, color='tab:olive', linestyles='dashdot', lw=1)
plt.legend(loc='best')
plt.show()

plt.figure()
plt.plot(freq, dF)
plt.show()

t = np.linspace(0, T, n)
uinp = [0] * n
uout = [0] * n
for i in range(n):
    uinp[i] = signal1(f*t[i])
    uout[i] = signal2(f*t[i])
plt.figure()
plt.plot(t, uinp, t, np.array(uout, dtype=complex).real)
plt.show()

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

fl = float(input('Нижняя граничная частота фильтра '))
fh = float(input('Верхняя граничная частота фильтра '))
f0 = (fl + fh) * 0.5
Z0 = float(input('Характеристическое сопротивление фильтра на частоте '+str(f0)+' '))

L, C1, C2 = calculate_filter_params(Z0, fl, fh)

print('Параметры фильтра:')
print('C1 = {0: f}\nC2 = {1: f}\nL = {2: f}'.format(C1, C2, L))

freq = np.linspace(0.8*fl, fh*1.2, n)

Gama = Gam(freq, L, C1, C2)
Zw = Zw_func(freq, L, C1, C2)
dF = (Gam(freq+0.01, L, C1, C2).imag-Gam(freq-0.01, L, C1, C2).imag) / 0.02

plt.figure()
plt.plot(freq, Gama.real, color='tab:blue', label=r'$\alpha(f)$')
plt.tick_params(axis='y', labelcolor='tab:blue')
plt.legend(loc='lower right')
plt.twinx()
plt.plot(freq, Gama.imag, color='tab:orange', label=r'$\phi(f)$')
plt.tick_params(axis='y', labelcolor='tab:orange')
plt.legend(loc='upper left')
plt.show()

plt.figure()
plt.plot(freq, abs(Zw), label='$|Z_0|(f)$')
plt.plot(freq, Zw.real, label='$Re(Z_0)(f)$')
plt.plot(freq, Zw.imag, label='$Im(Z_0)(f)$')
plt.vlines(f0, 0, Z0, color='tab:olive', linestyles='dashdot', lw=1)
plt.hlines(Z0, freq[0], f, color='tab:olive', linestyles='dashdot', lw=1)
plt.legend(loc='best')
plt.show()

plt.figure()
plt.plot(freq, dF)
plt.show()

t = np.linspace(0, T, n)
uinp = [0] * n
uout = [0] * n
for i in range(n):
    uinp[i] = signal1(f*t[i])
    uout[i] = signal2(f*t[i])
plt.figure()
plt.plot(t, uinp, t, np.array(uout, dtype=complex).real)
plt.show()