# -*- coding: utf-8 -*-
"""описис_02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IdM1u7uMBmD9TccOD--c368zTiEa1ejr
"""

import numpy as np
from math import *
import matplotlib.pyplot as plt

def signal_1(x):
    return 1.0 + sin(2.0*pi*x) + 2.0 * cos(4.0*pi*x) + 0.5 * cos(6.0*pi*x)

def signal_2(x):
    return 3.0 + sin(4.0*pi*x) + 1.0 * cos(7.0*pi*x) + 2.0 * cos(9.0*pi*x)

def signal_3(x):
    return 3.0 + sin(4.0*pi*x) + 1.0 * cos(7.0*pi*x) + 2.0 * cos(9.0*pi*x) + 5.0 * cos(6.0*pi*x)

#Дискретное преобразование Фурье
def dft(data):
    n = len(data)
    spectr = [0+0j] * n
    coef = 2.0 / n
    arg = pi * coef
    for j in range(n):
        spectr[j] = 0.0 + 0.0j
        for i in range(n):
            spectr[j] += data[i] * (cos(arg*i*j) - sin(arg*i*j)*1j)
    return np.array(spectr, dtype=complex)

def pew(u, f, T, n):
  print('Расчет ДПФ...')
  spec1 = dft(u)
  print('Расчет БПФ...')
  spec2 = np.fft.fft(u)
  freq = np.fft.fftfreq(n, T/n)   #np.linspace(0, n/T, n)

  plt.figure()
  plt.plot(t, u)
  plt.show()

  plt.figure()
  plt.plot(freq[0:n//2], (np.hypot(spec1.real, spec1.imag)/n*2.0)[0:n//2], label='ДПФ')
  plt.plot(freq[0:n//2], (np.hypot(spec2.real, spec2.imag)/n*2.0)[0:n//2], '-.', label='БПФ')
  plt.legend(loc='best')
  plt.xlim(0, 50)
  plt.show()

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
t = np.linspace(0, T, n)
u_1 = [0] * n
u_2 = [0] * n
u_3 = [0] * n
for i in range(n):
    u_1[i] = signal_1(f*t[i])
    u_2[i] = signal_2(f*t[i])
    u_3[i] = signal_3(f*t[i])
print('Сигнал 1')
pew(u_1, f, T, n)
print('Сигнал 2')
pew(u_2, f, T, n)
print('Сигнал 3')
pew(u_3, f, T, n)

# 10
# 1
# 256

import numpy as np
from math import *
import matplotlib.pyplot as plt

def signal(x):
  tau = 1.0
  T = 5.0
  if x % 5 < 4:
    return 0
  else:
    return 5

#Дискретное преобразование Фурье
def dft(data):
    n = len(data)
    spectr = [0+0j] * n
    coef = 2.0 / n
    arg = pi * coef
    for j in range(n):
        spectr[j] = 0.0 + 0.0j
        for i in range(n):
            spectr[j] += data[i] * (cos(arg*i*j) - sin(arg*i*j)*1j)
    return np.array(spectr, dtype=complex)

def pew(u, f, T, n):


  print('Расчет ДПФ...')
  spec1 = dft(u)
  print('Расчет БПФ...')
  spec2 = np.fft.fft(u)
  freq = np.fft.fftfreq(n, T/n)   #np.linspace(0, n/T, n)

  plt.figure()
  plt.plot(t, u)
  plt.show()

  plt.figure()
  plt.plot(freq[0:n//2], (np.hypot(spec1.real, spec1.imag)/n*2.0)[0:n//2], label='ДПФ')
  plt.plot(freq[0:n//2], (np.hypot(spec2.real, spec2.imag)/n*2.0)[0:n//2], '-.', label='БПФ')
  plt.legend(loc='best')
  plt.xlim(0, 50)
  plt.show()

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))
t = np.linspace(0, T, n)
u = [0] * n
for i in range(n):
    u[i] = signal(f*t[i])

print('Сигнал 3')
pew(u, f, T, n)

# 10
# 1
# 512
# можно добавить огибающую: S(w)=U_0/q*sin(w/2*tau_u)/(w/2*T)

import numpy as np
from math import *
import matplotlib.pyplot as plt

def signal(x):
    tau = 1.0  # Длительность импульса
    T = 5.0    # Период сигнала
    if x % T < T - tau:
        return 0
    else:
        return 5  # Амплитуда сигнала

# Дискретное преобразование Фурье
def dft(data):
    n = len(data)
    spectr = [0+0j] * n
    coef = 2.0 / n
    arg = pi * coef
    for j in range(n):
        spectr[j] = 0.0 + 0.0j
        for i in range(n):
            spectr[j] += data[i] * (cos(arg*i*j) - sin(arg*i*j)*1j)
    return np.array(spectr, dtype=complex)

def pew(u, f, T, n):
    print('Расчет ДПФ...')
    spec1 = dft(u)
    print('Расчет БПФ...')
    spec2 = np.fft.fft(u)
    freq = np.fft.fftfreq(n, T/n)  # Частотная шкала

    # Временная область
    plt.figure()
    plt.plot(t, u)
    plt.title('Сигнал во временной области')
    plt.xlabel('Время, с')
    plt.ylabel('Амплитуда')
    plt.grid(True)
    plt.show()

    # АЧХ с использованием ДПФ и БПФ
    plt.figure()
    plt.plot(freq[0:n//2], (np.abs(spec1)/n*2.0)[0:n//2], label='ДПФ', color='blue')
    plt.plot(freq[0:n//2], (np.abs(spec2)/n*2.0)[0:n//2], '-.', label='БПФ', color='orange')

    # Огибающая АЧХ прямоугольного импульса
    tau = 1.0  # Длительность импульса
    U0 = 5.0   # Амплитуда сигнала
    omega = 2 * np.pi * freq[0:n//2]
    envelope = U0 * np.sinc(omega * tau / (2 * np.pi))  # sinc(x) = sin(pi*x)/(pi*x)

    # Масштабируем огибающую для лучшей визуализации
    envelope *= T / tau  # Нормировка для совпадения амплитуды

    plt.plot(freq[0:n//2], np.abs(envelope), label='Огибающая', color='green')

    plt.title('АЧХ сигнала')
    plt.xlabel('Частота, Гц')
    plt.ylabel('Амплитуда')
    plt.legend(loc='best')
    plt.xlim(0, 50)
    plt.grid(True)
    plt.show()

# Ввод параметров
f = float(input('Опорная частота сигнала: '))
T = float(input('Временной интервал: '))
n = int(input('Число временных отсчетов: '))

# Создание временной шкалы и сигнала
t = np.linspace(0, T, n)
u = [signal(f*t[i]) for i in range(n)]

print('Сигнал 3')
pew(u, f, T, n)
