# -*- coding: utf-8 -*-
"""описис_04.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/126m6FG74jd0_zW6XMTadSVZAPnBAaTXu
"""

import numpy as np
from math import *
import matplotlib.pyplot as plt

def filter(time, signal, fl, fh):
    n = len(signal)
    freq = np.fft.fftfreq(n, time[1]-time[0])
    spectr = np.fft.fft(signal)
    for i in range(n):
        if not fl < abs(freq[i]) < fh:
            spectr[i] = 0+0j
    return np.fft.ifft(spectr)

"""Смоделировать работу фильтра низких, высоких частот и полосового фильтра, выделяя по одной гармонике"""

def signal(x):
    return sin(2.0*pi*x) + 2.0 * cos(2.0 * 2.0*pi*x) + 0.5 * cos(3.0 * 2.0*pi*x)

def main():
  f = float(input('Опорная частота сигнала '))
  T = float(input('Временной интервал '))
  n = int(input('Число временных отсчетов '))

  t = np.linspace(0, T, n)
  u = [0] * n
  for i in range(n):
      u[i] = signal(f*t[i])

  print('Расчет БПФ...')
  spec = np.fft.fft(u)
  freq = np.fft.fftfreq(n, T/n)

  print('Расчет ФНЧ...')
  sig_lf = filter(t, u, 0, 1.5*f)
  print('Расчет ПФ...')
  sig_pb = filter(t, u, 1.5*f, 2.5*f)
  print('Расчет ФВЧ...')
  sig_hf = filter(t, u, 2.5*f, 3.5*f)

  print('Расчет БПФ...')
  spec_lf = np.fft.fft(sig_lf)
  spec_pb = np.fft.fft(sig_pb)
  spec_hf = np.fft.fft(sig_hf)

  plt.figure()
  plt.plot(t, u)
  plt.axis(xmin=0, xmax=1/f)
  plt.show()

  plt.figure()
  plt.plot(freq[0:n//2], (np.hypot(spec.real, spec.imag)/n*2.0)[0:n//2])
  plt.axis(xmin=0, xmax=4*f)
  plt.show()

  plt.figure()
  plt.plot(t, sig_lf.real, label='ФНЧ')
  plt.plot(t, sig_pb.real, '--', label='ПФ')
  plt.plot(t, sig_hf.real, '-.', label='ФВЧ')
  plt.legend(loc='best')
  plt.axis(xmin=0, xmax=1/f)
  plt.show()

  plt.figure()
  plt.plot(freq[0:n//2], (np.hypot(spec_lf.real, spec_lf.imag)/n*2.0)[0:n//2], '-', label='ФНЧ')
  plt.plot(freq[0:n//2], (np.hypot(spec_pb.real, spec_pb.imag)/n*2.0)[0:n//2], '--', label='ПФ')
  plt.plot(freq[0:n//2], (np.hypot(spec_hf.real, spec_hf.imag)/n*2.0)[0:n//2], '-.', label='ФВЧ')
  plt.axis(xmin=0, xmax=4*f)
  plt.legend(loc='best')
  plt.show()

main()

def signal(x):
    return sin(2.0*pi*x) + 2.0 * cos(2.0 * 2.0*pi*x) + 1.5 * cos(2.5 * 2.0*pi*x) + 0.5 * cos(3.0 * 2.0*pi*x)

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

t = np.linspace(0, T, n)
u = [0] * n
for i in range(n):
    u[i] = signal(f*t[i])

print('Расчет БПФ...')
spec = np.fft.fft(u)
freq = np.fft.fftfreq(n, T/n)

print('Расчет ПФ...')
sig_pb = filter(t, u, 1.5*f, 2.5*f)

print('Расчет БПФ...')
spec_pb = np.fft.fft(sig_pb)

plt.figure()
plt.plot(t, u)
plt.axis(xmin=0, xmax=1/f)
plt.show()

plt.figure()
plt.plot(freq[0:n//2], (np.hypot(spec.real, spec.imag)/n*2.0)[0:n//2])
plt.axis(xmin=0, xmax=4*f)
plt.show()

plt.figure()

plt.plot(t, sig_pb.real, '--', label='ПФ')

plt.legend(loc='best')
plt.axis(xmin=0, xmax=1/f)
plt.show()

plt.figure()

plt.plot(freq[0:n//2], (np.hypot(spec_pb.real, spec_pb.imag)/n*2.0)[0:n//2], '--', label='ПФ')

plt.axis(xmin=0, xmax=4*f)
plt.legend(loc='best')
plt.show()

"""Провести фильтрацию периодической последовательности прямоугольных импульсов для 3, 1 и ½ лепестков"""

def signal(x):
  tau = 1.0
  T = 5.0
  if x % 5 < 4:
    return 0
  else:
    return 5

def filter(time, signal, fl, fh):
    n = len(signal)
    freq = np.fft.fftfreq(n, time[1]-time[0])
    spectr = np.fft.fft(signal)
    for i in range(n):
        if not fl < abs(freq[i]) < fh:
            spectr[i] = 0+0j
    return np.fft.ifft(spectr)

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

t = np.linspace(0, T, n)
u = [0] * n
for i in range(n):
    u[i] = signal(f*t[i])

print('Расчет БПФ...')
spec = np.fft.fft(u)
freq = np.fft.fftfreq(n, T/n)

print('Расчет ПФ...')
sig_pb = filter(t, u, 0, 3/tau)

print('Расчет БПФ...')
spec_pb = np.fft.fft(sig_pb)

plt.figure()
plt.plot(t, u)
plt.axis(xmin=0, xmax=1)
plt.show()

plt.figure()
plt.plot(freq[0:n//2], (np.hypot(spec.real, spec.imag)/n*2.0)[0:n//2])
plt.axis(xmin=0, xmax=4*f)
plt.show()

plt.figure()

plt.plot(t, sig_pb.real, '--', label='ФНЧ')

plt.legend(loc='best')
plt.axis(xmin=0, xmax=1)
plt.show()

plt.figure()

plt.plot(freq[0:n//2], (np.hypot(spec_pb.real, spec_pb.imag)/n*2.0)[0:n//2], '-', label='ФНЧ')

plt.axis(xmin=0, xmax=4*f)
plt.legend(loc='best')
plt.show()

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

t = np.linspace(0, T, n)
u = [0] * n
for i in range(n):
    u[i] = signal(f*t[i])

print('Расчет БПФ...')
spec = np.fft.fft(u)
freq = np.fft.fftfreq(n, T/n)

print('Расчет ПФ...')
sig_pb = filter(t, u, 0, 1/tau)

print('Расчет БПФ...')
spec_pb = np.fft.fft(sig_pb)

plt.figure()
plt.plot(t, u)
plt.axis(xmin=0, xmax=1)
plt.show()

plt.figure()
plt.plot(freq[0:n//2], (np.hypot(spec.real, spec.imag)/n*2.0)[0:n//2])
plt.axis(xmin=0, xmax=4*f)
plt.show()

plt.figure()

plt.plot(t, sig_pb.real, '--', label='ФНЧ')

plt.legend(loc='best')
plt.axis(xmin=0, xmax=1)
plt.show()

plt.figure()

plt.plot(freq[0:n//2], (np.hypot(spec_pb.real, spec_pb.imag)/n*2.0)[0:n//2], '-', label='ФНЧ')

plt.axis(xmin=0, xmax=4*f)
plt.legend(loc='best')
plt.show()

f = float(input('Опорная частота сигнала '))
T = float(input('Временной интервал '))
n = int(input('Число временных отсчетов '))

t = np.linspace(0, T, n)
u = [0] * n
for i in range(n):
    u[i] = signal(f*t[i])

print('Расчет БПФ...')
spec = np.fft.fft(u)
freq = np.fft.fftfreq(n, T/n)

print('Расчет ПФ...')
sig_pb = filter(t, u, 0, 1/2/tau)

print('Расчет БПФ...')
spec_pb = np.fft.fft(sig_pb)

plt.figure()
plt.plot(t, u)
plt.axis(xmin=0, xmax=1)
plt.show()

plt.figure()
plt.plot(freq[0:n//2], (np.hypot(spec.real, spec.imag)/n*2.0)[0:n//2])
plt.axis(xmin=0, xmax=4*f)
plt.show()

plt.figure()

plt.plot(t, sig_pb.real, '--', label='ФНЧ')

plt.legend(loc='best')
plt.axis(xmin=0, xmax=1)
plt.show()

plt.figure()

plt.plot(freq[0:n//2], (np.hypot(spec_pb.real, spec_pb.imag)/n*2.0)[0:n//2], '-', label='ФНЧ')

plt.axis(xmin=0, xmax=4*f)
plt.legend(loc='best')
plt.show()